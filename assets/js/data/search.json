[ { "title": "『世界一流エンジニアの思考法』読書メモ: 仕事は楽しむもの", "url": "/24/08/world-class-engieer/", "categories": "Career", "tags": "Reading Notes, Team Building", "date": "2024-08-29 00:00:00 +0900", "snippet": "最近、世界一流エンジニアの思考法という本とても人気があるようで、読んでみた。「Team Geek」や「Clean Agile」、「NO HARD WORK!」などの本と似たような観点が多いと感じるが、あらためて考えさせられる部分も多かった。以下、個人的に印象に残った部分をメモ。理解に時間をかけるプログラミングの仕事で、わからないバグやエラーが日常的に発生している。その時、エンジニア、特に初心...", "content": "最近、世界一流エンジニアの思考法という本とても人気があるようで、読んでみた。「Team Geek」や「Clean Agile」、「NO HARD WORK!」などの本と似たような観点が多いと感じるが、あらためて考えさせられる部分も多かった。以下、個人的に印象に残った部分をメモ。理解に時間をかけるプログラミングの仕事で、わからないバグやエラーが日常的に発生している。その時、エンジニア、特に初心者がやりがちなのは、とりあえず色々試行錯誤を始める。AIのおかげで、今はエラーログを投げるとすぐたくさんの可能性と解決策が出てくる。そのままコピペでは、たまにうまくいくこともあるが、よくあるのは、たくさん試しても解決できてない。ただ時間を無駄にしてしまうだけ。それは、そのバグの挙動を理解していないからだ。すぐに手を動かすより、まずそのエラーが何を意味しているのか、どういう状況で発生しているのか、事実をもとに原因を推測する。そして、仮説を検証する。個人的によく感じているのは、私が毎回GPTのアドバイスを一つずつ試そうとしているのは、基礎知識が足りないかもしれない。だから、最初の仮説すら立てられない。そのため、まずは基礎知識を学び、理解することが重要だと感じた。そしてその場での解決だけでなく、発生理由をちゃんと時間かけても理解し、知識を積み重ねて、体系化することを心がける。Be lazy仕事を効率化するというのは、より少ない時間で価値を最大化するということ。優先順位をつける単にタスクの優先順位をつけて一つずつやるのでなく、「一番重要な一個だけを選ぶ」ということがポイント。つまり、優先順位をつけることの目的は、一番重要なタスクだけに集中すること。他のタスクはやらない。2-8則を応用する。80%の成果は20%のタスクで達成できる。その20%のタスクを見つけて、それに集中する。会議の準備と持ち帰りはやめる日本では、会議の準備と宿題の持ち帰りが当たり前だが、それは無駄な時間を使っているだけ。会議の場で全てを完結することを目指すべき。「楽に達成できる」計画で仕事をするソフトウエア開発上は、常に不確実性がつきまとう。だから、計画は柔軟であるべき。火急の依頼が「マネジメント能力の欠如」とみなされる。それは依頼先に負担をかけるだけでなく、納期を割る確率が高い賭けをしていることになる。計画をするとき、その人の能力を考慮し、プラス余裕を持たせることが重要。無理なら、きちんと断ることも大切。疲弊の連鎖を回避するために。コミュニケーションの極意気軽に聞ける空気の大切さ特にリモートワークでは、気軽に質問できる環境が重要。quick callを活用するのが効率的。わからないことについて、自分でドキュメントを読んだり、調べたりすることが大切だが、新しいプロジェクトなどバックグラウンドがない場合、関係する人に直接質問する方が早い。それも効率化の一つ。意見が対立しても「否定しない」自分の意見を言うとき、必ず相手の意見を否定しないことが鉄則。仕事は楽しむもの仕事を我慢するのでなく、楽しむことが大切。マネージャーは単なる進捗確認や指示出すのでなく、メンバーが楽しめる仕事の環境を作ることが重要。1on1で常に、「仕事を楽しんているか」を確認することが大切。メンバーの答えがノーだったら、その理由を探り、改善策を考える。日本でも中国でも、1on1でよくあるのは、「誰かを見習え」とか「もっと頑張れ」とかの話が多いが、それより、今楽しんでいるか、を先に聞くべき。メンバーの個性を尊重し、楽しめる環境を作ることが、チームの生産性を高める。" }, { "title": "\"drain\" event を使ってメモリリークを防ぐ", "url": "/24/08/js-dl-memory-leak/", "categories": "Coding", "tags": "JavaScript, Node.js", "date": "2024-08-09 00:00:00 +0900", "snippet": "背景あるcsvファイルのダウンロード処理で、下記のようなデータ加工して、csv streamに書き込む処理がある。// csv（配列データ）の作成function　writeStream(data, writer) {\t\tdata.forEach((dataRow) =&gt; {\t\t\tconst result = processData(dataRow);\t\t\twriter.write(r...", "content": "背景あるcsvファイルのダウンロード処理で、下記のようなデータ加工して、csv streamに書き込む処理がある。// csv（配列データ）の作成function　writeStream(data, writer) {\t\tdata.forEach((dataRow) =&gt; {\t\t\tconst result = processData(dataRow);\t\t\twriter.write(result);\t\t});\t\twriter.end();\t}function processData(dataRow) { // データの加工処理 return processedData; }csvローデータが数万行以上の場合、データをDLする際にJavaScript heap out of memory　エラーが発生する。2023-07-11T00:21:25: &lt;--- Last few GCs ---&gt;2023-07-11T00:21:25:2023-07-11T00:21:25: [2482:0x605fd60] 18348258 ms: Scavenge 4033.7 (4126.2) -&gt; 4033.4 (4134.2) MB, 24.7 / 0.0 ms (average mu = 0.756, current mu = 0.490) allocation failure;2023-07-11T00:21:25: [2482:0x605fd60] 18348307 ms: Scavenge 4040.3 (4134.2) -&gt; 4040.2 (4134.2) MB, 38.3 / 0.0 ms (average mu = 0.756, current mu = 0.490) allocation failure;2023-07-11T00:21:25: [2482:0x605fd60] 18348350 ms: Scavenge 4041.1 (4134.2) -&gt; 4040.3 (4150.2) MB, 41.9 / 0.0 ms (average mu = 0.756, current mu = 0.490) allocation failure;2023-07-11T00:21:25:2023-07-11T00:21:25:2023-07-11T00:21:25: &lt;--- JS stacktrace ---&gt;2023-07-11T00:21:25:2023-07-11T00:21:25: FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory2023-07-11T00:21:25: 1: 0xb6b850 node::Abort() [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 2: 0xa806a6 [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 3: 0xd52140 v8::Utils::ReportOOMFailure(v8::internal::Isolate*, char const*, bool) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 4: 0xd524e7 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, bool) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 5: 0xf2fbe5 [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 6: 0xf420cd v8::internal::Heap::CollectGarbage(v8::internal::AllocationSpace, v8::internal::GarbageCollectionReason, v8::GCCallbackFlags) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 7: 0xf1c7ce v8::internal::HeapAllocator::AllocateRawWithLightRetrySlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 8: 0xf1db97 v8::internal::HeapAllocator::AllocateRawWithRetryOrFailSlowPath(int, v8::internal::AllocationType, v8::internal::AllocationOrigin, v8::internal::AllocationAlignment) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 9: 0xefed6a v8::internal::Factory::NewFillerObject(int, v8::internal::AllocationAlignment, v8::internal::AllocationType, v8::internal::AllocationOrigin) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 10: 0x12c265f v8::internal::Runtime_AllocateInYoungGeneration(int, unsigned long*, v8::internal::Isolate*) [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:21:25: 11: 0x16ef479 [/home/v18/.nvm/versions/node/v18.13.0/bin/node]2023-07-11T00:22:05: [7] Worker died : [PID 2482] [Signal SIGABRT] [Code null]だた、画面経由でなく、直接curlやwgetでDLする場合は問題ない。curl -o test.csv http://localhost:3000/api/download最初は、axiosに問題があると思われたが、fetch APIでも同じエラーが発生した。Heap Snapshotsを取得してみると、データ処理の途中データがメモリに大量に残っていることがわかった。問題点data.forEachでデータを処理しているが、データを一気にstreamに書き込みとしていることで、フロントでのダウンロード処理が遅いと、メモリに保存するデータが膨らんでいき、メモリリークが発生する。解決策drainイベントを使って、streamが書き込み可能になったタイミングで次のデータを書き込むようにする。async function　writeStream(data, writer) { try {\t for await (const dataRow of data) {\t\t\t\tconst result = processData(dataRow);\t\t\t\t\tif (!writer.write(result)) {\t\t\t\t\t\tawait new Promise((resolve) =&gt; writer.once(\"drain\", resolve));\t\t\t\t\t}\t\t\t}\t\t} finally {\t\t\twriter.end();\t\t}\t}stream自体がデーターの溜まり状況を判断できる。writable.write()がfalseを返す場合は、streamにbuffer溜まっていることを示しているため、データーのforループを一時ストップさせ、書き込みを中止する。streamのbufferがなくなったら(つまりdrainになった)、次のループを継続し、書き込みを再開する。ただ、なぜwgetを使うとき、メモリリークが発生しない点について、あくまで推測として、wgetはメモリに一時保存することなく、直接ファイルに書き込むため、ダウンロード処理スピードがaxiosやfetchより速いかもしれない。また、wgetがHTTP/1.0 を使っている。HTTP/1.0はHTTP/1.1よりもシンプルで、影響あるかどうかは不明。参照:Using Heap SnapshotNode.js Stream　Event: ‘drain’" }, { "title": "ドメイン駆動設計についての理解", "url": "/24/05/domain-driven-design-fundamental/", "categories": "Coding", "tags": "Reading Notes, System Design", "date": "2024-05-26 00:00:00 +0900", "snippet": "最近、ドメイン駆動設計入門という本を読んだ。この本では、値オブジェクトやドメインサービスなど、多くの概念が紹介されているが、それらの概念を全力で理解しようとした結果、ドメイン駆動設計の基本的な考え方がかえって理解しにくくなってしまった。そこで英語で情報を検索し、いくつかの資料を読んだ後、特にエリック・エバンス本人の講演動画（What is DDD - Eric Evans - DDD Eur...", "content": "最近、ドメイン駆動設計入門という本を読んだ。この本では、値オブジェクトやドメインサービスなど、多くの概念が紹介されているが、それらの概念を全力で理解しようとした結果、ドメイン駆動設計の基本的な考え方がかえって理解しにくくなってしまった。そこで英語で情報を検索し、いくつかの資料を読んだ後、特にエリック・エバンス本人の講演動画（What is DDD - Eric Evans - DDD Europe 2019）を視聴した。これにより、DDDの基本的な考え方についてなんとなくイメージが付いたと思うので、メモとして残しておく。ドメイン駆動設計とはドメイン駆動設計（DDD）は、ソフトウェアを設計するためのアプローチであり、ビジネスドメインの知識に焦点を当て、その知識をソフトウェアモデルに抽象化する。「ドメイン」とは、ビジネス領域の特定の知識のこと。 例えば、銀行業界のドメインには、口座、取引、顧客、支店などの概念が含まれる。ドメインを重視する理由なぜドメインから始めるのかというと、ソフトウェアは最終的にユーザーに使用されるものであり、ビジネスシナリオは非常に複雑である可能性があるからだ。特定のビジネスに関する十分な知識がなければ、エンジニアが自分の理解に基づいてソフトウェアを設計しても、それがユーザーの実際のニーズを満たすことができないかもしれないし、ビジネスの変化に対応できない可能性が高くなり、最終的にはソフトウェアプロジェクトが失敗する原因になる。ドメインの知識をモデルに抽象化する方法DDDの提案する解答は、ビジネスドメインの専門家と密接に協力して、ビジネスドメインの複雑さと詳細を理解すること。エリック・エバンスは講演で、彼らが使う言葉に注意深く耳を傾けることが重要だと述べている。ビジネスの専門家がビジネスを説明するときに使う語彙や例に注意深く耳を傾けることで、モデル化される概念が明らかになる。また、キーワードを探すことも重要であり、エバンスは完璧な解決策を見つけようとすることに注意を促した。万能のように見える完璧なモデルで問題を説明するのは大きな間違いだと。ビジネスの専門家がこれらの用語をどのように表現しているかに特に注意を払う。 これらの言葉を記録し、擬似コードを書くのに使うことができる。講演動画の中で、エバンスはある物流システムを例に挙げている。 このシステムでは、カーゴという一つのモデルと輸送ルートを処理するルーティング・サービスを使っている。しかし、ビジネスの専門家の説明をよく聞いてみると、カーゴ(貨物)、旅程、ストップ、区間といった複数の用語を使っていることがわかる。貨物は、出発地と目的地を含む旅程を持ち、旅程には複数の区間があり、それぞれが異なるストップを通過し、異なるストップを通過する際に荷下ろしと荷積みを行う場合がある。ビジネスシナリオがこれらの用語で記述されると、モデルはより自然に構築できるだろう。ユビキタス言語(共通言語)DDDでは、ビジネスの専門家と開発者の間に共通言語が必要であり、この言語はユビキタス言語（共通言語）と呼ばれる。この共通言語は通常、ビジネスドメインの概念を記述するために使用されるドメイン専門用語であり、この言語はビジネスの専門家と開発者の間のコミュニケーションと理解の架け橋となる。より一般的には、ある概念について、ビジネスの専門家とエンジニアは同じ語彙を使って記述する必要がある。例えば、私の仕事上は、単発なアンケート調査をアドホックと呼ぶ。個人的には単発的調査と表現したいが、クライアントとのコミュニケーションでは、アドホックと表現した方が圧倒的に共通理解が得やすい。DDDでは、すべてのクラス、すべてのメソッド、すべての変数が、ビジネスと一貫性のある方法で注意深く命名されるべきと強調。それによって語られるストーリーが、あなたが書いているビジネスのストーリーになると考えている。 将来、顧客やユーザーと新機能やエラー報告について議論するとき、お互いを理解することが容易になると。つまり、コード自体がビジネスの現実を反映すること。境界づけられたコンテキスト(Bounded Contexts)DDDにおけるもう一つの重要な概念は、「境界づけられたコンテキスト」である。言語をモデルに抽象化するとき、異なるモデル間の境界にも注意を払う必要がある。例えば、私が最近担当した案件では、ある製品のコンセプト調査がすでにクライアントのシステムに存在しており、アクティビティ、ジョブ、コンセプトなどの概念が使用されていた。しかし、クライアントが製品の広告調査を追加する必要があるとき、アクティビティ、ジョブ、コンセプトなどの概念も使用されているにもかかわらず、これらの概念の内容は少し異なっている。 これは、コンセプト調査と広告調査のビジネスシーンや目的が異なるからだ。また、クライアント企業内では、将来的にこの2つの調査種類は異なる部署が管理する可能性もあるので、モデルを設計する際には、混乱を避けるために、この2つのモデルの境界を考慮する必要がある。このように理解すると、実は単一責任原則と共通するかもしれない。後者は、モデルが1つの責任しか持てないだけでなく、1人または一つの関連する代表的なグループのみに対して責任を負うべきであることを強調している。モデリングに使用できるテクニック上記の基本概念を理解した後、DDDはこれらのモデルをコードで実装する方法について、Entity、Value Object、Repository、Factory、Aggregate、Service、Domain Eventなど、多くの概念を紹介する。これらの概念を最初に理解しようとすると、迷子になりやすいし、中には本当に混乱しやすい概念もあると思う。このブログ(DDD 101 - The 5-Minute Tour)が非常にわかりやすく要約しているので、ここに原文から直接引用することにする。 You model your business using Entities (the ID matters) and Value Objects (the values matter). You use Repositories to retrieve and store them. You create them with the help of Factories. If an object is too complex for a single class, you’ll create Aggregates that will bind Entities &amp; Value Objects under the same root. If a business logic doesn’t belong to a given object, you’ll define Services that will manipulate the involved elements. Eventually, when the state of the business changes (a change that matters to business experts), you’ll publish Domain Events to communicate the change. エンティティ（IDが重要）と値オブジェクト（値が重要）でビジネスをモデル化する。 それらを取得および保存するためにリポジトリを使用 モデルの作成が複雑だったら、ファクトリを使う。 オブジェクトが単一のクラスに複雑すぎる場合、エンティティと値オブジェクトを同じルートの下にバインドするアグリゲートを作成する。 ビジネスロジックが特定のオブジェクトに属さない場合、関連する要素を操作するサービスを定義する。 最終的に、ビジネスの状態が変化すると（ビジネスエキスパートにとって重要な変化）、ドメインイベントを発行して変更を通知する。以上はドメイン駆動設計について、現段階の基本理解だけど、今後理解を深くするため、原書を読む予定。参照 DDD 101 — The 5-Minute Tour Anemic Domain Model Domain-Driven Design (DDD) The Single Responsibility Principle" }, { "title": "『Team Geek』読書メモ: ソフトウエア開発はチームスポーツである", "url": "/24/05/team-geek/", "categories": "Career", "tags": "Reading Notes, Team Building", "date": "2024-05-04 00:00:00 +0900", "snippet": "Team Geek――Googleのギークたちはいかにしてチームを作るのかという本は、「自分のプログラマーキャリアに最も影響を与えているいくつかの本の一つ」として、複数のブログで推薦されていることを見かけたので、GW期間中に読み終えた。以下、読書メモ。ソフトウエア開発はチームスポーツであるエンジニアリングは簡単だ。人間が難しい。プログラムとして成功するには、最新の言語を覚えたり高速なコードを...", "content": "Team Geek――Googleのギークたちはいかにしてチームを作るのかという本は、「自分のプログラマーキャリアに最も影響を与えているいくつかの本の一つ」として、複数のブログで推薦されていることを見かけたので、GW期間中に読み終えた。以下、読書メモ。ソフトウエア開発はチームスポーツであるエンジニアリングは簡単だ。人間が難しい。プログラムとして成功するには、最新の言語を覚えたり高速なコードを書いたりするだけではいけない。プログラマは、常にチームで仕事をする。君が思っている以上に、チームは個人の生産性や幸福に直接影響する。本書の基本的な考え：ソフトウエア開発はチームスポーツであるり、技術的要因と同じだけ人の要因が影響するというものだ。このチームスポーツの考え方が本書で何度も強調されている。天才プログラマーの神話を破るプログラマーのコミュニティには、天才プログラマーの神話がある。しかし、実際には、素晴らしい成果の背後には、必ずチームがいる。優れたアイデアやプログラミングスキルがあっても、開発したソフトウェアが必ずしも成功するとは限らない。多くのプログラマは、開始したばかりの作業を共有したいとは思わない。完璧ではないコードが見られ、バカだと思われるのが怖いからだ。しかし、隠したらダメになる。失敗のリスクが高くなる。「早い段階で、高速に、何度も失敗せよ」の精神を忘れないよう。早い段階から成果を共有することで、つまづきを回避したりアイデアを検査したりできるようになる。自分の成長にもつながる。プロジェクトのバス係数を高めることもできる。※バス係数：チームの中で何人がバスに轢かれたら、プロジェクトが破綻するのか。つまり、一人だけ情報を持っていると、その人がバスに轢かれたら、プロジェクトは破綻する。情報を共有することで、バス係数を高めることができる。チームがすべてビジョンを共有しよう。仕事を分担しよう。他人から学ぼう。素晴らしいチームを作ろう。HRTの三本柱：「謙虚」「尊敬」「信頼」 謙虚(Humility) 自分が全知全能ではないし、絶対に正しいわけでもない。常に自分を改善していこう。 尊敬(Respect) 一緒に働く人のことを心から尊敬しよう。相手を一人の人間として扱い、その能力や功績を高く評価しよう。 信頼(Trust) 自分以外の人は有能であり、正しいことをすると信じよう。そうすれば、仕事を任せることができる。 あらゆる人間関係の衝突は、謙虚・尊敬・信頼の欠如によるものだ。 人間関係の力を過少評価してはいけない。人間関係は確実にプロジェクトよりも長続きするものである。 実践HRT エゴをなくす。何でも知っているかのような印象を与えてはいけない。 自分の価値を自分の書いたコードと結び付けてはいけない。 相手に対する疑問ではなく、自分の疑問として謙虚に聞く。 「このフローは間違っている。こうすべき」ではなく、「このフローはよくわからないが、こうしたら読みやすくなるでしょうか？」にすれば、相手も受け入れやすい。 過ちから学ぶには、失敗を文書化すること。何を学んだか、何を変更するかを記述する。 優れた例： 概要 イベントのタイムライン 影響と損害の評価 すぐに問題を解決するための行動一式 再発を防止するための行動一式 学習した教訓 弱みを見せる。間違いや能力不足を認めることは、長期的に立場を向上させるのである。時には「わからない」と言うことが大切。素晴らしいチーム文化を作るチーム文化とはチームの文化とは、エンジニアリングチームが共有する経験・価値・目標のことである。コードレビュー、テスト駆動開発、事前の設計書など開発に関係するものもあれば、毎週木曜日のランチには決まったレストランに行ったり、金曜日には行きつけのバーに飲みに行ったりするような、人間関係にまつわるものもある。プロダクトの開発方法、社員への接し方、競合との戦い方などあらゆる側面に浸透しているもの。ただ、チーム文化は強烈な個性を持つ新来者が現れると、簡単に変えてしまう可能性あるため、チームは文化を維持・防衛する必要がある。新来者がチームリーダーから文化を教えてもらうのでなく、チームメンバーから学ぶのであるチームがどのように働いているのか、どのようにやり取りをしているのか、どのように問題に取り込んでいるのかを観察することで、チームの文化がわかるようになる。成功するチーム文化のコミュニケーションパタンコミュニケーションの原則は、 同期コミュニケーション（ミーティングなど）の人数を減らし、と 非同期コミュニケーション（メール、ドキュメントなど）の人数を増やすこと。効率的なミーティングミーティングは作業時間の邪魔になる。頻繫なミーティングで作業を中断させられていたら、エンジニアはゾーンに入ることができない。３～４時間のブロックを「多忙」や「クリエイターの時間」にして、まとめて仕事を片付けよう。ミーティングを開くときの５つの原則： 絶対に必要な人だけを呼ぶ。 アジェンダを作ってミーティング開始前に配布する。 ミーティングのゴールを達成したら時間前でも終了 ミーティングを順調に進める ミーティングの開始時間を強制的に中断される時間（お昼休みや終業時間）の前に設定する。最も重要なのは、アジェンダが済んだら、ミーティングを終了すること。「リーダー」は新しい「マネージャー」伝統的なマネージャーはどうやって仕事を完了させるかを考える。リーダーは何ができるかを考える。どうやって仕事を完了させるかはチームに考えてもらう。リーダーはそのための道を作る。マネージャーは労働者を管理したくなる衝動を抑えるべき。マネージャーの役割として、最も重要なのは、執事や召使いのようにチームに奉仕することだ。謙虚・尊敬・信頼の雰囲気を作り出さなければいけない。リーダーのアンチパターン 自分の言いなりになる人を採用する パフォーマンスが低い人を無視する わずか１～２人のパフォーマンスの低い人がいるだけで、チームはうまくいかなくなってしまう。 低パフォーマンスの人をコーチングするには、 期限を設定して、達成してもらいたい目標を決める 小さな成功を何度も経験するため、最初の目標は小さくして、少しずつ大きくする 成功か失敗かを判断できるように、マイルストーンを明確な期待で設定する。 毎週進捗を確認する。続けられないようなら、早い段階で中止する。 人間的な側面を無視する 例：仕事と家庭を両立したい人に対して、在宅勤務を許可しない。 チームを子供として扱う 人は自分が扱わるように行動する。つまり、子供や囚人のように扱えば、チームはそのように振る舞う。 マイクロマネジメントしたり、その人の能力を貶したり、仕事の責任を与えなかったりすればすぐに伝わる。 信頼していることを伝えれば、相手は普段魅せないような力を発揮してくれる。 メンターになるための要素 チームのプロセスとシステムの経験 誰かに教える能力 相手がどれだけ支援を必要としているかを把握する能力。これが一番重要。チームの幸せを追い求めるリーダーとして、チームを長期にわたって生産的に（そして離脱者を少なく）するには、時間を作ってチームの幸せを計測すればよい。チームの幸せを追い求めるには、1対1のミーティングのあとに「何か必要なのものはある？」と質問するといいだろう。チームメンバーのキャリアを追い求めるということもである。誰もがやりたいことを持っている。昇進。新しいことを学ぶ。すごいものをローンチする。頭の良い人と仕事する。口に出さなくてもエンジニアは様々なことを歓迎る。有能なリーダーになりたければ、こうしたことをどうすれば実現できるかを考えるべきだ。そして、きちんと考えいてることをチームに知らせるべきだ。ここで重要なのは、暗黙的な目標を明確化することである。チームのモチベーションを高める人を幸せで生産的にするのは、外部的動機（例えば、報酬）よりも内発的動機（例えば、楽しさ）を高めることである。内発的動機には、自律性、熟達、目的の三つの要素が必要だ。 自律性 自分で考えて行動できる。 熟達 新しいスキルを学び、既有のスキルを向上させるための機会を作る。 目的 仕事の目的が見つかれば、モチベーションと生産性が驚異的に向上する。 有害な人に対処する排除するのは、あくまでも振る舞いであり、特定の個人ではない。個人を「いい」とか、「悪い」とかで考えるのは単純すぎる。目に余る振る舞いを特定して、そのことを批判するほうが建設的で実践的である。有害な脅威の例 他人の時間を尊重しない エゴ 権利を与えすぎる 未熟なコミュニケーションと複雑なコミュニケーション 被害妄想 完璧主義理想：チームがうまく機能している会社理想なマネージャーマネージャーが君に成功を支援してくれるのであれば、マネージャーの仕事を楽にできる簡単なことがある。 責任の範囲を広げよう 先を見越した行動や責任を自ら求める振る舞いによって、マネージャーの作業を軽減することができるし、今のレベル以上の仕事が可能なことも提示できる。 リスクをとろう 失敗を恐れるな。すばやく学習できるし、何ができて何ができないのかがわかるし、時間をかけて成長していくこともできる。 大人らしく振る舞おう 自分が期待することを他人に伝えるべき。 質問しよう 納得できないことをマネージャーが決めたとしたら、その根拠について質問したり議論したりすることを恐れてはいけない。 マネージャーはエスパーではない リーダーから何かを聞かれる前に、こちらから何をしているかを報告しよう。コミュニケーションを取りすぎているひとはいないので、躊躇することはない。 障害物に遭遇した時、仕事がうまくいったとき、何かが必要なとき、何かを期待しているときに、マネージャーに知らせよう。そうすると、マイクロマネジメントの回避にもなる。マネージャーが監視に来るのと同じ頻度でメールを送ることで、マネージャーが確実に来なくなる。 現実:　環境が成功の邪魔になっている 悪いマネージャー 失敗に対する不安によって、保守的になる。 情報を隠そうとする。 悪い組織 官僚制や手続きを導入することによって、会社の成功を妨げるようになる。 経営者はエンジニアをビジネスゴールを達成するための手段だと考えて、従業員を犠牲にして、非現実的な要求を作り出してしまう。 最悪の組織は、封建制度のような指揮統制型の構造。 例えば、バグの受け渡しに厳格なルールのある会社。 バグを修正するには、責任のあるチームにメールで連絡するのではなく、自分たちで徹夜でバグを再現して、データを収集し、障害報告書を作成する必要があった。マネージャーにメールを送ると、マネージャーがディレクターにメールを送る。そのディレクターがメールをチームのマネージャーに送る。そこから１０日以上過ぎてから、二人のマネージャー、二人のディレクター、三人のエンジニアと一緒に、このバグをすぐに修正するのか、次のローンチまで保留するのか、というミーティングを開く。 会社から言うことを聞かない子どものように扱われていないだろうか？Firewallが厳しすぎて、普通のサイトが見れないことないだろうか？１日の行動を詳細にタイムカードに記録する必要はないだろうか？１週間に書いたコード行数のような意味のない方法で生産性を計測する会社もあるくらい。逆に、Googleでの例を見ると、Gmailのタイポを見つけた時、ソースコードを開いて、タイポを修正して、Ｇmailチームにパッチをメールすると、ここから感謝してもらえた。そのような組織に入ったらどうする？ 組織を動かして、自分の仕事に利用できる仕組みをみつけよう。 プランＢ：逃げよう。" }, { "title": "MongoDBのreplica setに新しいsecondary nodeを追加する手順", "url": "/24/04/secondary-mongodb-setup/", "categories": "Coding", "tags": "MongoDB, replica set", "date": "2024-04-21 00:00:00 +0900", "snippet": "背景分散DBとして、もう一台のDBサーバーを構築し、新しいsecondary nodeとして既存のMongoDBのreplica setに追加する作業を行った。作業前は、既存のMongoDB replica setは以下のような構成であった。 primary node secondary node arbiter node作業後は、二つのsecondary nodeが存在する構成となる...", "content": "背景分散DBとして、もう一台のDBサーバーを構築し、新しいsecondary nodeとして既存のMongoDBのreplica setに追加する作業を行った。作業前は、既存のMongoDB replica setは以下のような構成であった。 primary node secondary node arbiter node作業後は、二つのsecondary nodeが存在する構成となる。作業環境 OS: AlmaLinux 8.5 MongoDB: 4.4.13作業手順分散サーバー上で新しいmongodb instance追加新しいDBサーバーを構築し、MongoDBをインストールする。 新しいDBサーバーのMongoDBの設定ファイルを編集する。$ sudo vi /etc/mongod.conf以下の設定を追加する。# mongod.conf# network interfacesnet: port: 27020 bindIp: 127.0.0.1,192.168.1.9 # IPアドレスを追加security: authorization: enabled keyFile: /var/lib/mongo/keyfile # keyfile位置要注意replication: replSetName: \"rs0\" # nameがprimary dbのreplSetNameと一致必要 MongoDBのkeyfileを同期する。primaryのkeyfileと一致する必要で、内容コピーか、scpで転送する。keyfileの一致を確認する。md5sum /var/lib/mongo/keyfile MongoDBの設定ファイルを再読み込みする。sudo systemctl restart mongod port 27020でMongoDBが起動していることを確認する。sudo netstat -tulnp | grep 27020 primaryサーバー向けてportを開ける。sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"PRIMARY_IP\" port protocol=\"tcp\" port=\"27020\" accept' sudo firewall-cmd --reload primaryサーバーから新しいsecondaryサーバーに接続できることを確認する。mongo --host 192.168.1.9 --port 27020primaryサーバーに新しいsecondary nodeを追加 bindIP追加のため、primaryサーバーの設定ファイルを編集する。DB再起動必要。元々はbindIpは127.0.0.1のみだったので、新しいDBサーバーと通信するため、既存のreplica setのDBたちにIPアドレスを追加する必要。confファイル修正後、DB再起動必要になるので、メインテナンス状態の事前通知など必要。# ip 確認ip a192.168.1.4# 分散secondaryサーバーから通信するため、各nodeのbindIp追加必要sudo vi /etc/mongod1.conf sudo vi /etc/mongod2.conf sudo vi /etc/mongod3.conf # network interfacesnet: port: 27017 bindIp: 127.0.0.1,192.168.1.4 # ip追加# service再起動sudo systemctl restart mongod1sudo systemctl restart mongod2sudo systemctl restart mongod3 新しいDBサーバー向けにportを開ける。# secondaryサーバー向けに port 開けるsudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.9\" port protocol=\"tcp\" port=\"27017\" accept'sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.9\" port protocol=\"tcp\" port=\"27018\" accept'sudo firewall-cmd --permanent --zone=public --add-rich-rule='rule family=\"ipv4\" source address=\"192.168.1.9\" port protocol=\"tcp\" port=\"27019\" accept'sudo firewall-cmd --reloadsudo firewall-cmd --list-all# secondary サーバーで疎通確認mongo --host 192.168.1.4 --port 27017 primaryサーバーで新しいsecondary nodeを追加する。mongo --port 27017# 認証情報入力後、replica set確認rs.status()# 上記で権限エラー出る可能性あり、root権限一旦再確認db.grantRolesToUser(\"root\", [\"root\"])rs.add(\"ip_or_hostname:port\")# e.g. rs.add(\"192.168.1.9:27020\")# 状態確認rs.status(){_id: 3,name: '192.168.1.9:27020', health: 1,state: 5,stateStr: 'STARTUP2', # stateStrが 'STARTUP2'の状態だと、追加成功。データ同期が自動始まるuptime: 1913,optime: { ts: Timestamp({ t: 0, i: 0 }), t: Long(\"-1\") },optimeDurable: { ts: Timestamp({ t: 0, i: 0 }), t: Long(\"-1\") },optimeDate: ISODate(\"1970-01-01T00:00:00.000Z\"),optimeDurableDate: ISODate(\"1970-01-01T00:00:00.000Z\"),lastAppliedWallTime: ISODate(\"1970-01-01T00:00:00.000Z\"),lastDurableWallTime: ISODate(\"1970-01-01T00:00:00.000Z\"),lastHeartbeat: ISODate(\"2024-04-03T15:02:43.649Z\"),lastHeartbeatRecv: ISODate(\"2024-04-03T15:02:42.639Z\"),pingMs: Long(\"0\"),lastHeartbeatMessage: '',syncSourceHost: 'test-secondary-db:27018', # syncSourceHostが元々のsecondary nodeのhost:portsyncSourceId: 1,infoMessage: '',configVersion: 8,configTerm: 40} 初期データ同期状態確認 secondary db 上でlog確認sudo tail -f /var/log/mongodb/mongod.log primary db上で、新しいsecondary nodeの同期状況確認# 同期状況確認admin&gt; rs.printSecondaryReplicationInfo()source: 192.168.102.152:27020# データ同期完了まで、ずっど初期時間になる{ syncedTo: 'Thu Jan 01 1970 09:00:00 GMT+0900 (日本標準時)', replLag: '-1712155645 secs (-475598.79 hrs) behind the primary '} # 以下同期完了状態rs.printSecondaryReplicationInfo()source: 192.168.102.152:27020{ syncedTo: 'Thu Apr 04 2024 00:12:05 GMT+0900 (日本標準時)', replLag: '0 secs (0 hrs) behind the primary '}rs.status(){ _id: 3, name: '192.168.1.9:27020', health: 1, state: 2, stateStr: 'SECONDARY', # stateSrtが 'SECONDARY'になると、同期完了}Troubleshooting新しいsecondary node追加時、以下のエラーが出る場合rs.add(\"192.168.1.9:27020\")MongoServerError: Either all host names in a replica set configuration must be localhost references, or none must be; found 3 out of 4エラー原因：既存のreplica setの設定ファイルに、各nodeのhost名がlocalhost/127.0.0.1のみ設定されているため、新しいsecondary nodeを追加する際にエラーが発生する。{_id: 1,name: 'localhost:27018', state: 2,stateStr: 'SECONDARY',...}解決方法: replica setの設定ファイルに、各nodeのnameをhostnameに変更する。ipも使えるが、このIPがすでにどれかのnode nameに使われる場合が前提なので、すべてがlocalhost/127.0.0.1の場合は、hostname使う必要。そうじゃないと、下記のようなエラーが出る。MongoServerError: No host described in new configuration with {version: 5, term: 32} for replica set LocalRep maps to this nodenameをhostnameに変更するため、以下の手順を実行する。# DBが使っているhostnameを確認&gt; db.serverStatus().host testdbvar cfg = rs.conf(); cfg.members[0].host = \"testdb:27017\";cfg.members[1].host = \"testdb:27018\";cfg.members[2].host = \"testdb:27019\";rs.reconfig(cfg, {force: true}); データが同期できない可能性1：hostname resolve問題secondary dbのlog確認時は、以下のようなReadConcernMajorityNotAvailableYetエラーが出る\"msg\":\"Failed to refresh key cache\",\"attr\": { \"error\":\"ReadConcernMajorityNotAvailableYet: Read concern majority reads are currently not possible.\", \"nextWakeupMillis\":6200}原因：hostname resolve問題で、secondary dbからprimary dbに接続できないsecondary dbで、primary dbに接続できるか確認する。mongo --host testdb --port 27017# 下記Host not foundエラー出る場合、hostname resolve問題確実connecting to: mongodb://testdb:27019/?compressors=disabled&amp;gssapiServiceName=mongodbError: couldn't connect to server testdb:27017, connection attempt failed: HostNotFound: Could not find address for testdb:27017: SocketException: Host not found (authoritative) :connect@src/mongo/shell/mongo.js:372:17@(connect):2:6exception: connect failedexiting with code 1解決方法: /etc/hostsファイルにhostnameを追加するsudo vi /etc/hosts# /etc/hosts192.168.1.4 testdb可能性2：keyfileが一致しないstatus確認時は、以下のようなPermission deniedエラーが出るrs.status(){ _id: 3, name: '192.168.1.9:27020', stateStr: '(not reachable/healthy)', 'Error connecting to 192.168.1.9:27020 :: caused by :: Permission denied',}そして、secondary dbのlog確認時は、以下のようなauthentication failedエラーが出る # db log error message{ \"t\": { \"$date\":\"2024-04-03T16:31:13.092+09:00\"}, \"s\":\"I\", \"c\":\"ACCESS\", \"id\":20249, \"ctx\":\"conn6122\", \"msg\":\"Authentication failed\", \"attr\":{ \"mechanism\":\"SCRAM-SHA-256\",\"speculative\":false,\"principalName\":\"__system\", \"authenticationDatabase\":\"local\", \"remote\":\"192.168.1..4:50362\", \"extraInfo\":{}, \"error\":\"AuthenticationFailed: SCRAM authentication failed, storedKey mismatch\" }}原因：keyfileが一致しない解決方法: keyfileの一致確認追記本番作業時、nodeのnameを変更直後、node間通信ができなくなり、primary nodeが出なくなるエラーが発生した。原因は、本番で使用するmongodbのバージョンは4.4で、ローカルマシンのhostnameが自動識別できないため、/etc/hostsファイルにhostnameを追加する必要がある。ただ、検証機での作業時は、mongodbのバージョンは5で、hostnameの自動識別が可能であるため、/etc/hostsファイルにhostnameを追加する必要がなかった。今後、検証作業時は、必ず本番環境と同じバージョンで作業することを心がける。参照MongoDB:Replication" }, { "title": "Clean Agile 感想: アジャイルは速く進むことではない", "url": "/24/02/clean-agile-reading-note/", "categories": "Career", "tags": "Agile, Reading Notes, Software Development, Robert C. Martin", "date": "2024-02-24 00:00:00 +0900", "snippet": "Twitterで見かけて、Clean Agile 基本に立ち戻れを読んでみた。この本では、アジャイル開発の具体的な実践方法より、アジャイルの歴史や考え方を説明している。特に近年アジャイルがよく誤解されている状況について、作者はアジャイルの第一人者として、自分の考えからアジャイルの本質を語っている。私は、いままでアジャイルは、チーム開発を迅速に推進するための方法論だと理解していた。この本を読ん...", "content": "Twitterで見かけて、Clean Agile 基本に立ち戻れを読んでみた。この本では、アジャイル開発の具体的な実践方法より、アジャイルの歴史や考え方を説明している。特に近年アジャイルがよく誤解されている状況について、作者はアジャイルの第一人者として、自分の考えからアジャイルの本質を語っている。私は、いままでアジャイルは、チーム開発を迅速に推進するための方法論だと理解していた。この本を読んだら、全くそうではないことがわかった。どちらというと、アジャイルは、納期を死守させるためではなく、遅れそうなプロジェクトを早期に発見し、適切な対応をするための方法論に近いほう。なぜいつも納期に間に合わないのか 考えている暇はない。納期は迫っているし、ステークホルダーが怒っている。プレッシャーが高まる。残業は急増する。退職者は続出する。誰もやる気を失っていた。こんなプロジェクトなど二度とやるかと誓った。この本の第一章を読むと、まさに本に書かれている状況通り、私は痛いほどこの現実を経験している。当然、スケジュール見積自体の問題やプロジェクト管理面、私自身のスキル不足など、様々な要因があると思うが、本に書かれているこの失敗光景にすごい共感を持っている。 スケジュールが遅れて、人員追加して、また遅れて、さらに追加して、結局これだけリソース投下しているのに、なぜうまくいかないのか？私の職場では、この本に書かれているように、みんなこの疑問を持っている。そして、この本では、以下で述べている。 人数が２倍になれば、２倍の速度で進むことを誰もが知っている。 だが、実際はその逆になる。「遅れているソフトウェアプロジェクトへの要員追加は、プロジェクトをさらに遅らせる」と、ブルックスの法則が指摘している。(「人月の神話」)なぜなら、２倍の人数が増えると、それ以上のコミュニケーションコストが増えるからだ。 新しいメンバーは未熟であり、既存のメンバーの活力を奪うため、数週間は生産性が落ちるはず。実際でも、毎回新しく入ってきたインターンに業務ロジックやコードの説明などで、かなりの時間を取られた。一日中、サポートに追われ、自分の業務が進まない状況が良くあった。鉄十字のトレードオフ 「品質」、「速度」、「費用」、「完成」のうち、好きな三つを選べる。四つは選べない。例えば、高品質で、高速で、安価なプロジェクトは、完成することはない。安価で、高速で、完成するプロジェクトは、高品質ではない。この鉄十字のトレードオフは、プロジェクトの進行において、常に意識しておきながら、バランスを取ることが重要だと。この法則を理解したうで、アジャイルはどのように支援してくれるのか。それが、開発の速度データを提供すること。チームのベロシティと残りのストーリーポイントを使って、プロジェクトの進行状況を予測することができる。ここで注意すべきなのは、開発中に新しい要求や課題が発見された場合は、残作業を再見積もりすることが重要だと。開発を確実に見積もることはできない 我々プログラマーは、作業にかかる時間を把握できない。それは、我々が無能だとか怠惰だとか、そういうことではない。実際に作業に取り掛かり、それが終わるまで、どれだけ複雑になるかを知る方法がないからだ。この結論は私にとってとても新鮮だった。見積もれないのは、単純に経験不足や事前の確認不足だを思った。でもよく考えると、確かにそうかも。完璧に見積もれるは、すべてのコードを脳内でシミュレーションできること。それは不可能ではないか。この現実を受け入れて、イテレーションを繰り返し、見積もりを修正しながら、誤差範囲を狭めることが重要だと。アジャイルは速く進むことではない このように、イテレーションを進めていくと、元の終了日には希望がなかったことが判明するまで、誤差範囲が狭まるはずだ。アジャイルは、希望を破壊する。 希望を持つとチームがマネージャーに進捗を誤解させてしまう。希望はプロジェクトをマネジメントするのに最悪の方法だ。アジャイルは早い段階から希望を殺し、継続的に冷たくて厳しくい現実を提供する。私のような、アジャイルは速く進むことだと思っている人もいるだろう。 だが、そうではない。これまでそうだったこともない。 アジャイルとは、どれだけうまくいっていないかをできるだけ早く知ることだ。そうすれば、状況をマネジメントできるからだ。マネージャーのやることは、データを収集し、そのデータをもとに最善の意思決定をすること。アジャイルは、プロジェクトをマネジメントするためのデータを生成する。このデータを使って、プロジェクトの成果を可能な限り最大化する。鉄十字のマネジメントそれでは、プロジェクトがうまくいってないことがわかったら、どうすればいいのか。前述した「品質」、「速度」、「費用」、「完成」の鉄十字をどう選択取捨するのか。結論というと、一番現実的なのは、「完成」、つまりスコープを変更すること。なぜなら、 ビジネス上、スケジュール、つまり納期の調整が高い確率で無理。 人員追加は、コストもかかるし、生産スピードが改善できるまで、十分な時間が必要。 品質を落とすと、さらに遅くなってしまう。汚いものはすべて遅いのだ唯一調整可能なのは、機能のスコープだ。本当に、この期限までに、すべての機能が必要なのか。一部後回しできないのか。この調整が最後の手段だ。その他の感想以上はあくまでこの本の第一章の内容だけ。でも十分な啓発を受けたと思う。アジャイルの実践方法について、この作者が書いた別の本を読む予定だが、この本では、ほかに新鮮と思ったところがまだたくさんある。ソフトウエアは安価に変更できるもの 「ソフト」とは、「変更しやすい」である。よって、「ソフトウェア」とは「変更しやすい製品」である。元々ソフトウエアが発明されたのは、マシンの動作をすばやく簡単に変更する方法が求められたから。動作の変更が難しいものこそ、「ハードウエア」と呼ばれる。確かに私でもそうだし、要件の変更に不満を持つ人は多いかも。でも、この本を読んで、そもそもソフトウエアは変更しやすいものだということを再認識した。もし「そんな変更したらアーキテクチャがダメになる」ことだったら、それはアーキテクチャがダメなのでは。 我々開発者は、変更を喜ぶべきだ。そのために我々は雇われている。我々の仕事は、変更を受け入れてエンジニアリングする能力と、そうした変更を比較的に安価にできるかどうかにかかっている。この言葉は、私の心に響いた。エンジニアの仕事は、変更を受け入れてエンジニアリングする能力だと。自分の仕事について、いま一度考え直したい。できない時は、「ノー」と言うべき 自分が雇われている理由は、コードを書く能力よりも「ノー」と言える能力のためだと自覚すべきだ。自分にしか、できるかどうかの判断をできないのだ。どれだけ納期のプレッシャーを感じていても、どれだけ多くのマネージャーたちが結果を求めていても、答えが本当に「ノー」であるなら、それを言うべきだと。いま振り返ってみたら、プロジェクト最初の段階で、このスケジュールでは無理だと思うことをはっきり伝えるべきだった。少なくとも、二回目の延期となったタイミングでも、もう一度「ノー」と言うべきだった。自分がスケジュール通りに行ってないことで怒られることを怯えて、実際テストなしでも、タスク完了したと報告したこともあった。そのあと、バグが多発し、結局、やり直す時間が「想定外時間」としてかかってしまった。連続二か月で土日残業深夜残業までをして、コードを書きたくないぐらい疲れた。それで本当に良かったのか。残業はダメ、持続可能なペースを作者はアジャイルの第一人者として、アジャイルの実践単位を「スプリント」と呼ばれることに反対している。なぜなら、スプリントという言葉は、短距離走のように、短期間で全力を出し切ることを意味する。だが、ソフトウエア開発は、短距離走の連続ではなく、マラソンである。長期にわたって、持続可能なペースで走り続けることが重要だと。 マネージャーから速く走れと言われることもあるだろうが、絶対に従わないでほしい。それは本当。最後まで持ちこたえられるように、自分のリソースをうまく節約するのは自分の責任だ。残業しても、プロジェクトが早く終わるわけではない。むしろ、疲れて、集中力が落ちて、結局時間がかかることが多い。また、残業をすることを誇りに思うひともいるかもしれないが、それは間違いだと。 あなたが計画できない人であり、合意すべきではない納期に合意した人であり、守れない約束をしたひとである、専門家ではなく、従順な労働者であることを示すだけだ。残業によって、スケジュールが短縮されるよりも、残業にかかるコストのほうが大きくなりやすいことを意識するべきだ。顧客と開発者の権利章典 顧客には、考えを途中で変えて機能を差し替えたり、プライオリティを変更したりする権利がある。その際に特別に多額の出費は必要ない。こちら、前述した「ソフトウエアは安価に変更できるもの」の考え方と一致するので、改めて意識しておきたい。 開発者には、常に質の高い仕事をする権利がある。これは、エンジニアとして、常に意識しておきたい。 開発者には、自ら見積りを行い、またそれを更新する権利がある。自分のタスクを見積もれる人は、自分以外にはいないこと。すでにタスクを見積もったあとでも、新たな要素が明らかになった場合には、いつでも見積りを変えられる。見積りはあくまで推測だ。見積りはけっして約束ではない。上記にすごく感謝な気持ちだけど、これを実践できるだろう。テスト駆動開発と複式簿記一つ面白い例えがあった。テスト駆動開発は、複式簿記に似ていると。複式簿記とは、帳簿に記入する取引は、必ず２回記入すること。一回は、貸方、もう一回は借方。開発に対しても、「必要となる振る舞いは、必ず２回入力する。」ということ。 一回目はテスト、二回目はそのテストをパスさせるコードだ。 両者を一緒に実行すると、結果はゼロになる。つまり、失敗したテストがゼロということ。テスト駆動開発について、面白い視点だと思った。一旦、この本の感想は以上。次は、アジャイル実践方法について、読んでみたいと思う。" }, { "title": "今日の反省: 本番反映前に絶対DBをバックアップしておくこと", "url": "/23/08/production-deploy-mistake/", "categories": "Others", "tags": "docker, PostgreSQL", "date": "2023-08-28 00:00:00 +0900", "snippet": "やってしまったこと今日は、エンジニアになってから最悪のミスを犯してしまった…まず、上司の指示を誤解して、自分で勝手にクライアントの本番サーバーでバージョンアップ作業を行った。当初の指示はバージョンアップ作業の手順をまとめることだけ。なぜか、私は本番反映もやると理解してしまった。クライアント側では、まだステージング環境での確認がまだ終わっていない。そもそも本番反映はサーバーを一度シャットダウン...", "content": "やってしまったこと今日は、エンジニアになってから最悪のミスを犯してしまった…まず、上司の指示を誤解して、自分で勝手にクライアントの本番サーバーでバージョンアップ作業を行った。当初の指示はバージョンアップ作業の手順をまとめることだけ。なぜか、私は本番反映もやると理解してしまった。クライアント側では、まだステージング環境での確認がまだ終わっていない。そもそも本番反映はサーバーを一度シャットダウンする必要があって、絶対に事前にクライアント側に確認すべきだった。そして、バージョンアップ作業する前に、現時点のデータベースのバックアップを怠ってしまった。リストア用データベースを作っておいたけど、使っていたデータは今朝cronでバックアップした分のみで、現在の最新データを使っていなかった。もしこの後、何か不具合が発生する場合、たとえデーターをリストアするとしても、データーの損失が発生する可能性がある。あるいは、新規マイグレーションをmigration downして、元のmigration状態に戻すこと。2年間分のマイグレーションファイルを一個一個rollbackすることは、リスクも非常に高い…結局、バージョンアップ後の不具合に気付き、バージョンを復元することになった。幸い、cronから作業時点までにまだ最新の更新がなかったので、直接dumpデーター使って直接リストアできた。今回の反省 上司の指示に対して、自分の理解に間違いがないか、必ず確認する。特に本番サーバーでの作業は、自分ひとりでやらないこと。本番反映は必ず二人以上で行うべきだった。 バージョンアップやデプロイする前に、必ず現在データーをバックアップすること。 " }, { "title": "JavaScriptフレームワークの過去、現在と未来", "url": "/23/02/future-of-javascript-framework/", "categories": "Coding", "tags": "JavaScript, React, Next.js", "date": "2023-02-22 00:00:00 +0900", "snippet": "フロントエンドの流行り廃りが激しいとよく言われるけど、なぜそんなに激しいのか、毎回の進化はどのような問題を解決しているのか、この動画はその進化の歴史をわかりやすく説明した。The past, current state &amp; future of JavaScript frameworks(ちなみに、この講師の udemy コースはとてもわかりやすく、React や node.js など...", "content": "フロントエンドの流行り廃りが激しいとよく言われるけど、なぜそんなに激しいのか、毎回の進化はどのような問題を解決しているのか、この動画はその進化の歴史をわかりやすく説明した。The past, current state &amp; future of JavaScript frameworks(ちなみに、この講師の udemy コースはとてもわかりやすく、React や node.js など全部おすすめ！JavaScript フレームワークの進化史この動画によると、JavaScript フレームワークの進化歴史を 7 つの段階に分けられる。Phase 1: 素の JavaScript 時代90 年代から 2000 年代前半までは、レガシーな JavaScript コードを書いていた暗黒時代…Phase 2: jQuery &amp; Ajax 時代2006 年、JavaScript ライブラリ jQuery が誕生した。JS コードを書くのはより簡単になり、異なるブラウザの非互換性の問題も解決された。特に Ajax のおかげで、データの取得が裏で行われ、毎回新しい HTML ファイルを取得する必要がないため、UX が大幅に改善された。Phase 3: JavaScript フレームワーク登場2010 年から、Ember.js や Backbone.js、Angular JS など初期の JS フレームワークが続々と誕生した。state 管理の概念が発明され、複雑な UI の実現がさらに簡単になった。Phase 4: React、Angular、Vue.js 2 御三家の登場2013 年、React 誕生2016 年、Angular、Vue.js 2 登場この三つのフレームワークは今でも JS フレームワークの御三家と呼ばれている。(最近のトレンドから見ると、React 一強になりつつある？)Phase 5: SPA や Client side rendering の流行御三家以外にも、たくさんの JS フレームワークが誕生している。この段階の主流思想は Client side rendering、つまり UIUX の実現はすべて JavaScript によってブラウザ側でコントロールする。Single page application が流行ってきた。Phase 6: SPA よりは静的サイト生成（SSG）SPA では、大量な JS コードを事前ダウンロードする必要があり、画面の読み込み速度に影響するほか、頻繁なデータ取得もサーバーに負担をかける。(SEO が対応できない問題も…)それらの問題を解決するため、全てをクライアントサイドで処理するより、一部のロジックをバックエンドに戻すという声が大きくなった。Next.js を代表として、Client side rendering よりは、静的サイト生成（Static site generation) を推奨するフレームワークが流行ってきた。Phase 7: Web の未来: Server Side Rendering への復帰直近では、React や Next.js をはじめ、画面表示のパフォーマンスを最大化するため、ブラウザ側の JS コードを極力削減する方向に進んでいる。サーバー側での静的サイト生成よりも進んだのは、(古き良きの)サーバーサイドレンダリング…昨年 3 月、React 18 がリリースされ、サーバーサイドレンダリングのサポートが宣言された。その後の 10 月、Next.js 13 がリリースされ、(まだ beta 版の機能だけど)、デフォルトでのサーバーサイドレンダリングが推奨された。(まだ SPA が流行りだと思っていたけど、Next.js 13 がリリースされた時はかなり衝撃を受けた。これって原点に戻ったのでは…?先日、Node.js の後継と見られる Deno の開発チームより、下記の記事が発表された。The Future (and the Past) of the Web is Server Side Renderingデバイスの多様化や異なる通信速度に対応するため、Web の未来は(過去も）サーバーサイドレンダリングと宣言されている。つまり、SPA はもう過去の流行りか…." }, { "title": "Railsのリクエストライフサイクルのについて", "url": "/22/11/rails-controller-instance-variable-lifecycle/", "categories": "Coding", "tags": "Ruby on Rails, API", "date": "2022-11-28 00:00:00 +0900", "snippet": "背景: Rails API での current_user についてこの間、Rails API を勉強した時、下記のコードに引っかかった。class Api::V1::BaseController &lt; ApplicationController include ActionController::HttpAuthentication::Token::ControllerMethods...", "content": "背景: Rails API での current_user についてこの間、Rails API を勉強した時、下記のコードに引っかかった。class Api::V1::BaseController &lt; ApplicationController include ActionController::HttpAuthentication::Token::ControllerMethods before_action :authenticate def authenticate authenticate_or_request_with_http_token do |token, _options| @_current_user ||= ApiKey.active.find_by(access_token: token)&amp;.user end end def current_user @_current_user endendこのコードの意図は、API 側で current_user を使えるようにすること。気になるのは、ここの||=演算子。 a ||= xxx &gt; 「||」演算子の自己代入演算子。a が 偽 か 未定義 なら a に xxx を代入する、という意味になります。@_current_user ||= ApiKey.active.find_by(access_token: token)&amp;.user直感で考えると、ユーザーがログインしている状態だったら、同じユーザーからリクエストが来る時、毎回 token を検証し、 DB にクエリしてユーザーを特定する必要がなくなるではないか。だったら、疑問がある。確か、HTTP リクエストはステートレスで、session や token などを使って、ユーザー状態を保持する仕組みになっていると思うけど、もし、ここでaccess_tokenを都度検証しない場合、どうやって同じユーザーだとわかるのか?他のユーザーからリクエストがきたら、同じcurrent_userと判断されないのか？もしかしたら、Rails controller は他の仕組みがあって、同じユーザーからのリクエストだとわかっているのか?通常のcurrent_userの使い方について似たような書き方はは Rails Tutorial の時に見たことがある。module SessionsHelper def current_user if (user_id = session[:user_id]) @current_user ||= User.find_by(id: user_id) end endendここは、View 側でcurrent_userを使うため、helper method として作ったもの。 current_user メソッドが１リクエスト内の処理で何度も呼び出されてしまうと、呼び出された回数と同じだけデータベースへの問い合わせが発生してしまい、結果として処理が完了するまでに時間がかかってしまうからです。 User.find_by の実行結果をインスタンス変数に保存することで、１リクエスト内におけるデータベースへの問い合わせは最初の１回だけになり、以後の呼び出しではインスタンス変数の結果を再利用するようになりますRails Tutorial の説明によると、ここのcurrent_userは同じリクエスト内に使うもの。つまり、同じリクエスト内で、ユーザーが特定できたら、View 側で何度もcurrent_userを呼び出しても、都度の DB クエリが必要なくなる。だとしたら、やはり異なるリクエストなら、current_user が同じユーザーかどうかという判断はできない?リクエストが来るとき、Rails はどう動いているのかそれなら、ユーザーからリクエストが来るとき、Rails は実際にどう対応しているのか。調べたら、下記のリソースが見つけた。The Lifecycle of a RequestStoring state across requests from the same user仮に、get '/posts' =&gt; 'posts#index'という route がある。そして、get '/posts'というリクエストが来るとき、Rails の対応は簡単にまとめると、こんな感じになる controller = PostsController.newで PostsController のインスタンスが作成される。 この controller には、三つのインスタンス変数が持つ - @request、@response、@params controller はindexアクションを実行する。 もしindexアクションで view テンプレート を render するなら、controller が持つインスタンス変数が view のインスタンスにコピーして渡される。 view インスタンスというのは、そのテンプレートのself。view ファイル内で使う変数は view インスタンスが controller または他の view インスタンスらコピした変数。 indexアクションの内容を実行完了後、controller インスタンスの任務が完了したので、そのまま廃棄される API の場合だと、もし最後の実行内容は JSON 形式のレスポンスを返すことなら、それを返した時点で、このリクエストの対応が完了になったので、controller インスタンスが捨てられる。 次のリクエストが来る時、また新しい controller インスタンスが作成られ、そのリクエストを対応する。 Rails controller のインスタンス変数のスコープとライフサイクルそうしたら、ここでの実行流れはこんな感じになると思う。class Api::V1::BaseController &lt; ApplicationController include ActionController::HttpAuthentication::Token::ControllerMethods before_action :authenticate def authenticate authenticate_or_request_with_http_token do |token, _options| @_current_user ||= ApiKey.active.find_by(access_token: token)&amp;.user end end def current_user @_current_user endendもしget '/posts'というリクエストが来たら、 PostController のインスタンスが生成される。 indexアクションを実行する前に、親クラスから継承したbefore_actionを実行する。 そして、@_current_userが初期化され、初めて値が代入される。 このリクエストが処理終了するまで、PostController のindexアクション内及びindexアクションによる呼び出される関連のメソッド内で、current_userを使って、ユーザーを取得できる indexアクションが実行完了されたら、PostController のインスタンスが廃棄される。その同時に、@_current_userインスタンス変数も当然捨てられる。controller が持つインスタンス変数は、同じリクエスト内でも、関連する view にコピして渡すことができる以外他の controller や他の controller の view、またはモデルでも利用することができない。ここの||=演算子について最初の疑問に戻ると、 Rails controller は異なるリクエストが同じユーザーから来たかどうか、token を検証する前に判断できない つまり、リクエストが来る度に、token の都度検証が必要。 そのため、新しいリクエストが来たら、 @_current_userが nil になっているので、ApiKey.active.find_by(access_token: token)&amp;.userが必ず実行されるこう見ると、ここでの||=演算子は普通の=と同じ結果..参照why cannot reassign class variables in controller of railsIs Rails shared-nothing or can separate requests access the same runtime variables?What is the scope of an instance variable in a Rails controller?Lifecycle of Instance variables in Ruby on RailsRuby on Rails Controller Instance Variable not sharedSharing data between threads" }, { "title": "Next.js編 - Rails + Next.js + Firebase V9 Authentication で認証付きのCRUDアプリを作る", "url": "/22/11/nextjs-firebase-auth/", "categories": "Coding", "tags": "React, Next.js, Rails, API, Firebase, TypeScript", "date": "2022-11-27 00:00:00 +0900", "snippet": "ソースコード：Backend: Rails API、Frontend: Next.jsデモページ：next-firebase-auth-sample-app利用技術フロントエンド Next.js TypeScript Tailwind CSSバックエンド Rails 7.0.4(API モード)認証部分 Firebase Authentication(V9) - Google ログ...", "content": "ソースコード：Backend: Rails API、Frontend: Next.jsデモページ：next-firebase-auth-sample-app利用技術フロントエンド Next.js TypeScript Tailwind CSSバックエンド Rails 7.0.4(API モード)認証部分 Firebase Authentication(V9) - Google ログインのみ背景最近、個人 PF で使う認証方式を検討している。最初は Auth0 を使おうと思っていたけど、実装で躓いて、代替案を探していたとき、Firebase Authentication が目に留まった。電話認証以外は基本的に無料で使えるし、利用できる認証方法も非常に豊富で、特に Auth0 が対応していない匿名認証もできる点に惹かれた。 特徴的なのは匿名認証で、一時的にユニークな ID を付与したユーザーとして扱いますが、その後他の認証方式に昇格することができます。参照：ちょっとでもセキュリティに自信がないなら、 Firebase Authentication を検討しよう認証機能全体の流れ 画面上のログインボタン押して、Google ログイン画面に遷移する。遷移形式は popup か redirect。 Firebase 側は Google から送られてきた ID Token を検証する。成功すれば、Firebase 側で user_id を生成し、ID Token を発行する。 Next.js 側は Firebase が発行する ID Token を取得して、Rails 側に送る。 Rails 側で Firebase ID Token を検証する。Firebase が発行した user_id を利用して、ユーザーを新規登録か既存ユーザーを特定する。 ユーザー情報の利用について Firebase 側で自動登録するユーザー個人情報はデフォルトで、email, displayName, photoUrl のみ 追加情報必要なら、下記のいずれの処理が必要 Google アカウント関連の情報なら Google Access Token を使って取得する Firebase Admin SDK 使って独自の情報コラムを追加する。 ユーザー個人情報を自前の DB で保存するなら、Rails 側で独自処理する Firebase Authentication の初期設定Firebase のアカウント取得やプロジェクト作成などの初期設定は他の記事を参照できるので、ここで省略。今回はユーザー利便性を考え、メール・パスワード形式を使わず、ソーシャルログインと匿名認証のみを実装予定で、まずは Google ログインを実装する。参照：Firebase の初期設定Next.js 側の実装まずは Firebase が発行した各種 key を環境変数に設定する// .env.localNEXT_PUBLIC_FIREBASE_API_KEY=&lt;YOUR_API_KEY&gt;;NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=&lt;YOUR_DOMAIN&gt;;NEXT_PUBLIC_FIREBASE_PROJECT_ID=&lt;YOUR_PROJECT_ID&gt;;NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=&lt;YOUR_STORAGE_BUCKET&gt;;NEXT_PUBLIC_FIREBASE_MESSEGING_SENDER_ID=&lt;YOUR_MESSEGING_SENDER_ID&gt;;NEXT_PUBLIC_FIREBASE_APP_ID=&lt;YOUR_APP_ID&gt;;※ この変数はブラウザ 側で処理するので、変数名にはNEXT_PUBLICを追加する必要 #exposing-environment-variables-to-the-browserそして、Firebase SDK インストール npm install --save firebaseFirebase 初期化と Firebase App オブジェクトを作成する// lib/initFirebase.tsimport { initializeApp, getApps, getApp } from \"firebase/app\";import { getAuth } from \"firebase/auth\";const firebaseConfig = { apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY, authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN, projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID, storageBucket: process.env.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET, messagingSenderId: process.env.NEXT_PUBLIC_FIREBASE_MESSEGING_SENDER_ID, appId: process.env.NEXT_PUBLIC_FIREBASE_APP_ID,};// Firebase初期化し、FirebaseAppオブジェクトを作成// appが既に存在する場合、そのappを取得するconst getFirebaseApp = () =&gt; { if (getApps().length === 0) { return initializeApp(firebaseConfig); } else { return getApp(); }};const app = getFirebaseApp();// FirebaseAppに関連付けられたAuthインスタンスを取得export const auth = getAuth(app);ログイン関数作成Firebase が提供するGoogleAuthProviderとsignInWithPopupを利用するimport { signInWithPopup, GoogleAuthProvider } from \"firebase/auth\";import { useRouter } from \"next/router\";import { auth } from \"../lib/initFirebase\";const loginWithGoogle = async () =&gt; { const provider = new GoogleAuthProvider(); const result = await signInWithPopup(auth, provider); if (result) { // ログインしたユーザー情報を取得する const user = result.user; // Google APIを直接利用したいなら、Google Access Tokenを取得できる const credential = GoogleAuthProvider.credentialFromResult(result); const token = credential?.accessToken; // ログイン成功後、ホームページにリダイレクト router.push(\"/\"); return user; }}; userから取得できる情報 displayName: string | null; // ユーザー表示名email: string | null; // ユーザーメールphoneNumber: string | null; // ユーザー電話番号photoURL: string | null; // Googleプロフィール写真URLuid: string; // Firebaseが生成するユニークID ちなみに、Google ログインページへの遷移を Redirect にしたいなら、signInWithRedirectを利用するimport { signInWithRedirect, GoogleAuthProvider } from \"firebase/auth\";const loginWithGoogle = async () =&gt; { const provider = new GoogleAuthProvider(); await signInWithRedirect(auth, provider); const result = await getRedirectResult(auth); if (result) { const user = result.user; ... }}ユーザーログイン状態の変化を監視するFirebase が提供するonAuthStateChanged関数を使って、ユーザーログイン状態を監視することができる。onAuthStateChanged関数の説明// Adds an observer for changes to the user's sign-in state.// @param auth — The Auth instance.// @param nextOrObserver — callback triggered on change.onAuthStateChanged(auth: Auth, nextOrObserver: NextOrObserver&lt;User&gt;): UnsubscribeuseFirebaseAuth()関数を作成する// hooks/useFirebaseAuth.tsimport { useState, useEffect } from \"react\";import { User, onAuthStateChanged } from \"firebase/auth\";import { useRouter } from \"next/router\";import { auth } from \"lib/initFirebase\";export default function useFirebaseAuth() { const [currentUser, setCurrentUser] = (useState &lt; User) | (null &gt; null); const [loading, setLoading] = useState(true); // listen for Firebase state change useEffect(() =&gt; { const unsubscribe = onAuthStateChanged(auth, nextOrObserver); return unsubscribe; }, []); const nextOrObserver = async (user: User | null) =&gt; { if (!user) { setLoading(false); return; } setLoading(true); setCurrentUser(user); setLoading(false); };}ログアウト関数追加const clear = () =&gt; { setCurrentUser(null); setLoading(false);};const logout = () =&gt; signOut(auth).then(clear);useFirebaseAuth()の全体像import { useState, useEffect } from \"react\";import { User, onAuthStateChanged, signOut, signInWithPopup, GoogleAuthProvider,} from \"firebase/auth\";import { useRouter } from \"next/router\";import { auth } from \"lib/initFirebase\";export default function useFirebaseAuth() { const [currentUser, setCurrentUser] = (useState &lt; User) | (null &gt; null); const [loading, setLoading] = useState(true); const router = useRouter(); const loginWithGoogle = async () =&gt; { const provider = new GoogleAuthProvider(); const result = await signInWithPopup(auth, provider); if (result) { const user = result.user; router.push(\"/\"); return user; } }; const clear = () =&gt; { setCurrentUser(null); setLoading(false); }; const logout = () =&gt; signOut(auth).then(clear); const nextOrObserver = async (user: User | null) =&gt; { if (!user) { setLoading(false); return; } setLoading(true); setCurrentUser(user); setLoading(false); }; useEffect(() =&gt; { const unsubscribe = onAuthStateChanged(auth, nextOrObserver); return unsubscribe; }, []); return { currentUser, loading, loginWithGoogle, logout, };}user context を作成するユーザー情報を app 内で共有するため、AuthContext を作成する// context/AuthContext.tsximport { createContext, useContext } from \"react\";import useFirebaseAuth from \"hooks/useFirebaseAuth\";import { User } from \"firebase/auth\";interface AuthContext { currentUser: User | null; loading: boolean; loginWithGoogle: () =&gt; Promise&lt;User | undefined&gt;; logout: () =&gt; Promise&lt;void&gt;;}type AuthProviderProps = { children: React.ReactNode;};const AuthCtx = createContext({} as AuthContext);const { currentUser, loading, loginWithGoogle, logout } = useFirebaseAuth();const AuthContext: AuthContext = { currentUser: currentUser, loading: loading, loginWithGoogle: loginWithGoogle, logout: logout,};export function AuthContextProvider({ children }: AuthProviderProps) { return &lt;AuthCtx.Provider value={AuthContext}&gt;{children}&lt;/AuthCtx.Provider&gt;;}// custom hook to use the userContext and access currentUser and loadingexport const useAuthContext = () =&gt; useContext(AuthCtx);context を全 app 範囲内で適用できるようにする。// pages/_app.tsximport type { AppProps } from \"next/app\";import \"../styles/globals.css\";import { AuthContextProvider } from \"../context/AuthContext\";export default function App({ Component, pageProps }: AppProps) { return ( &lt;AuthContextProvider&gt; &lt;Component {...pageProps} /&gt; &lt;/AuthContextProvider&gt; );}ログイン必要なページ内で、ユーザーログイン状況を確認するimport { useEffect } from \"react\";import { useRouter } from \"next/router\";import { useAuthContext } from \"../context/AuthContext\";export default function ProtectedPage() { const { currentUser, loading } = useAuthContext(); const router = useRouter(); // ログインしていないユーザーであれば、ログインページへ飛ばす useEffect(() =&gt; { if (!loading &amp;&amp; !currentUser) { router.push(\"/login\"); } }, [currentUser, loading]); return &lt;h1&gt;This page only for logged in users.&lt;/h1&gt;;}ログイン成功後、ID token 取得して Rails 側へ送るuser オブジェクトはgetIdTokenメソッドを使って、Firebase が発行した idToken を取得できる。/** * Returns a JSON Web Token (JWT) used to identify the user to a Firebase service. * * @remarks * Returns the current token if it has not expired or if it will not expire in the next five * minutes. Otherwise, this will refresh the token and return a new one. * * @param forceRefresh - Force refresh regardless of token expiration. */getIdToken(forceRefresh?: boolean): Promise&lt;string&gt;;axios の使用方法についてはここで省略。import axios from \"axios\";import useFirebaseAuth from \"hooks/useFirebaseAuth\";export default function LoginPage() { const { loginWithGoogle } = useFirebaseAuth(); const handleGoogleLogin = () =&gt; { const verifyIdToken = async () =&gt; { const user = await loginWithGoogle(); const token = await user?.getIdToken(); const config = { headers: { authorization: `Bearer ${token}` }, }; try { axios.post(\"/auth\", null, config); } catch (err) { let message; if (axios.isAxiosError(err) &amp;&amp; err.response) { console.error(err.response.data.message); } else { message = String(err); console.error(message); } } }; verifyIdToken(); }; return ( &lt;div&gt; &lt;button onClick={handleGoogleLogin}&gt; &lt;span&gt;Sign in with Google&lt;/span&gt; &lt;/button&gt; &lt;/div&gt; );}これでフロントエンド側の実装は完了した。大変参考になったリソース コメント内で最新 Firebase v9 バージョン適用したコードを PR されたので、すごく参考になった。Implementing authentication in Next.js with Firebase Firebase v8 バージョン使っているけど、参考になった。 Next.js × TypeScript × Firebase Authentication で Google 認証を実装する onAuthStateChangedを利用した hooks ライブラリもある。自前で context 実装必要ないので、便利らしい react-firebase-hooks Rails API 側の実装Rails 編はこちら -&gt; Rails 側の実装" }, { "title": "Rails編 - Rails + Next.js + Firebase V9 Authentication で認証付きのCRUDアプリを作る", "url": "/22/11/rails-firebase-auth/", "categories": "Coding", "tags": "React, Next.js, Rails, API, Firebase, TypeScript", "date": "2022-11-16 00:00:00 +0900", "snippet": "ソースコード：Backend: Rails API、Frontend: Next.jsデモページ：next-firebase-auth-sample-app利用技術フロントエンド Next.js TypeScript Tailwind CSSバックエンド Rails 7.0.4(API モード)認証部分 Firebase Authentication(V9) - Google ログ...", "content": "ソースコード：Backend: Rails API、Frontend: Next.jsデモページ：next-firebase-auth-sample-app利用技術フロントエンド Next.js TypeScript Tailwind CSSバックエンド Rails 7.0.4(API モード)認証部分 Firebase Authentication(V9) - Google ログインのみ背景最近、個人 PF で使う認証方式を検討している。最初は Auth0 を使おうと思っていたけど、実装で躓いて、代替案を探していたとき、Firebase Authentication が目に留まった。電話認証以外は基本的に無料で使えるし、利用できる認証方法も非常に豊富で、特に Auth0 が対応していない匿名認証もできる点に惹かれた。 特徴的なのは匿名認証で、一時的にユニークな ID を付与したユーザーとして扱いますが、その後他の認証方式に昇格することができます。参照：ちょっとでもセキュリティに自信がないなら、 Firebase Authentication を検討しよう認証機能全体の流れ 画面上のログインボタン押して、Google ログイン画面に遷移する。遷移形式は popup か redirect。 Firebase 側は Google から送られてきた ID Token を検証する。成功すれば、Firebase 側で user_id を生成し、ID Token を発行する。 Next.js 側は Firebase が発行する ID Token を取得して、Rails 側に送る。 Rails 側で Firebase ID Token を検証する。Firebase が発行した user_id を利用して、ユーザーを新規登録か既存ユーザーを特定する。 ユーザー情報の利用について Firebase 側で自動登録するユーザー個人情報はデフォルトで、email, displayName, photoUrl のみ 追加情報必要なら、下記のいずれの処理が必要 Google アカウント関連の情報なら Google Access Token を使って取得する Firebase Admin SDK 使って独自の情報コラムを追加する。 ユーザー個人情報を自前の DB で保存するなら、Rails 側で独自処理する Firebase Authentication の初期設定Firebase のアカウント取得やプロジェクト作成などの初期設定は他の記事を参照できるので、ここで省略。今回はユーザー利便性を考え、メール・パスワード形式を使わず、ソーシャルログインと匿名認証のみを実装予定で、まずは Google ログインを実装する。参照：Firebase の初期設定Rails API 側の実装Rails でやることは Next.js から送られてきた ID Token を検証すること。本来 Firebase が提供する Admin SDK を使えば簡単になるけど、SDK がサポートしているバックエンド言語は Node.js, Java, Python, Go と C# のみで、残念ながら Ruby がサポートされていない。公式説明の通り、第三者の JWT ライブラリを使って token を検証する必要がある。JWT ライブラリは、ruby では ruby-jwtがあるので、それを使って、token を検証することができる。※ 検証ロジックは自前で実装以外に、gem を使うなど他の選択肢もある。関連記事もあるので、詳細はここで省略。 firebase-admin-sdk-ruby firebase_id_token firebase-auth-rails 検証の流れについて公式説明の通り、Firebase: Verify ID tokens using a third-party JWT library検証内容は三つある。 トークン のヘッダー、ペイロードと署名。検証内容一覧 ID Token Header alg(Algorithm): 署名作成のアルゴリズムは “RS256”であること kid(Key ID ): Key ID は Google 公開鍵証明書リストの key の一つと一致すること ID Token Payload exp(Expiration time ): token の有効期限は過ぎていないこと。 iat(Issued-at time ): token の発行日時は過去であること。 aud(Audience): token の想定利用者識別子は project_ID と一致すること。 iss(Issuer): token の発行者識別子は”https://securetoken.google.com/\"と一致すること sub(Subject): uid となるユニークな値は空でない文字列であること。 ID Token Signature 最後に、Google 公開鍵証明書サイトから、kidと関連する証明書を取得し、公開鍵を生成して、署名の有効性を検証する ここで特に注意必要なのは、token を２回 decode する必要があること。token 署名を検証するための公開鍵を特定するには、token ヘッダー内のkid(Key ID)を使う必要がある。そのため、token を検証する前に、まず検証なしで token を decode し、kid属性を取得する。そして、取得した公開鍵を使って、再度 JWT.decodeメソッド で token を検証する。詳細やり方検証ロジックのコードは/app/lib/firebase_auth.rbファイルに置いている。全体コードはこちら：※. rails デフォルトの/libを使わず、/app下に別途/libを作るのは、/app配下のファイルは自動的にロードされるから。基本設定 rails new my-app —api gem を追加する。jwt、rack-cors、dotenv-rails config/initializers/cors.rb設定Rails.application.config.middleware.insert_before 0, Rack::Cors do allow do origins \"http://localhost:3000\" resource \"*\", headers: :any, methods: %i[get post put patch delete options head] endend config/puma.rbで rails のサーバポートを 3001 に設定。今回は Next.js 側は 3000 にしたので。port ENV.fetch(\"PORT\") { 3001 } project id を環境変数に設定するproject id はaudとissの検証に使うので、まず環境変数に設定する。 .envファイルを作成し、FIREBASE_PROJECT_ID=\"XXXXXXXX\"を追加する。※. .envファイルを.gitignoreに追加するのを忘れなく。 FIREBASE_PROJECT_ID = ENV[\"FIREBASE_PROJECT_ID\"]で project id を使う。ついでに、いくつかの定数を定義する。ALGORITHM = \"RS256\".freeze# \"iss\"は \"https://securetoken.google.com/&lt;FIREBASE_PROJECT_ID&gt;\"ISSUER_PREFIX = \"https://securetoken.google.com/\".freezeFIREBASE_PROJECT_ID = ENV[\"FIREBASE_PROJECT_ID\"]# 下記のURLからGoogle公開鍵証明書リストを取得するCERT_URI = \"https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com\".freeze検証メソッドラッパーこのラッパーメソッドのロジックは： token を decode して、中身を取得する 取得した header を使って、公開鍵を取得する 公開鍵を使って、token を検証する token 検証失敗したら、error 情報を返す token 検証成功したら、ユーザー uid を返すdef verify_id_token(id_token) payload, header = decode_unverified(id_token) public_key = get_public_key(header) error = verify(id_token, public_key) if errors.empty? return { uid: payload[\"user_id\"] } else return { errors: errors.join(\" / \") } endend最後に返す payload 中身はこんな感じ{ name: \"&lt;username&gt;\", picture: \"&lt;user_profile_picture&gt;\", iss: \"https://securetoken.google.com/&lt;FIREBASE_PROJECT_ID&gt;\", aud: \"&lt;firebase_project_id&gt;\", auth_time: 1_668_430_866, user_id: \"&lt;user_id&gt;(same as sub)\", sub: \"&lt;subject&gt;\", iat: 1_668_488_296, exp: 1_668_491_896, email: \"&lt;user email&gt;\", email_verified: true, firebase: { identities: { \"google.com\": [\"&lt;google_user_id&gt;\"], email: [\"&lt;user_gmail&gt;\"], }, sign_in_provider: \"google.com\", },}Step 1: 検証なしで token を decode するまず、token を検証なしで decode する。def decode_unverified(token) decode_token( token: token, key: nil, verify: false, options: { algorithm: ALGORITHM, }, )end# Returns:# Array: decoded data of ID token =&gt;# [# {\"data\"=&gt;\"data\"}, # payload# {\"typ\"=&gt;\"JWT\", \"alg\"=&gt;\"alg\", \"kid\"=&gt;\"kid\"} # header# ]def decode_token(token:, key:, verify:, options:) JWT.decode(token, key, verify, options)endruby-jwtの使い方は github から参照できる。参照： ruby-jwtdecodeメソッド引数の中身はこんな感じ。JWT.decode(token, key=nil, verify=false, option={algorithm: ALGORITHM})ruby-jwtの保守管理者からの返答によると、ここのverifyをfalseにすることで、JWT.decodeは token データの抽出のみを行い、検証プロセスを飛ばすので、処理速度が速く、全体のパフォーマンスに影響がないはず。ここで decode したデータの形式は[ { aud: \"&lt;firebase_project_id&gt;\", auth_time: 1_668_430_866, user_id: \"&lt;user_id&gt;(same as sub)\", sub: \"&lt;subject&gt;\", ...略 }, # payload部分 { alg: \"RS256\", kid: \"XXXXXXX\", typ: \"JWT\" } # header部分]となるので、payload, header = decode_unverified(id_token)でそれぞれを取得する。Step 2: 公開鍵を取得する続いて公開鍵を取得する。# 公開鍵取得のラッパーメソッドdef get_public_key(header) certificate = find_certificate(header[\"kid\"]) public_key = OpenSSL::X509::Certificate.new(certificate).public_keyrescue OpenSSL::X509::CertificateError =&gt; e raise \"Invalid certificate. #{e.message}\" return public_keyendGoogle 公開鍵証明書リストにアクセスするとわかると思うけど、ここに載せている証明書は{key: value}のハッシュ形式で、ペアが二つあり、うち一つの key は今回のkidと一致する。{ key_1: \"CERTIFICATE_1中身\", key_2: \"CERTIFICATE_2中身\" }そして、kidを使って、今回に使う公開鍵証明書を特定する。def find_certificate(kid) certificates = fetch_certificates unless certificates.keys.include?(kid) raise \"Invalid 'kid', do not correspond to one of valid public keys.\" end valid_certificate = certificates[kid] return valid_certificateend# CERT_URLから証明書リストを取得するdef fetch_certificates uri = URI.parse(CERT_URI) https = Net::HTTP.new(uri.host, uri.port) https.use_ssl = true req = Net::HTTP::Get.new(uri.path) res = https.request(req) unless res.code == \"200\" raise \"Error: can't obtain valid public key certificates from Google.\" end certificates = JSON.parse(res.body) return certificatesendStep 3: token の有効性を検証するsubとalgはJWT.decodeで自動検証できないため、追加検証必要。def verify(token, key) errors = [] begin decoded_token = decode_token( token: token, key: key, verify: true, options: decode_options, ) rescue JWT::ExpiredSignature errors &lt;&lt; \"Firebase ID token has expired. Get a fresh token from your app and try again.\" rescue JWT::InvalidIatError errors &lt;&lt; \"Invalid ID token. 'Issued-at time' (iat) must be in the past.\" rescue JWT::InvalidIssuerError errors &lt;&lt; \"Invalid ID token. 'Issuer' (iss) Must be 'https://securetoken.google.com/&lt;firebase_project_id&gt;'.\" rescue JWT::InvalidAudError errors &lt;&lt; \"Invalid ID token. 'Audience' (aud) must be your Firebase project ID.\" rescue JWT::VerificationError =&gt; e errors &lt;&lt; \"Firebase ID token has invalid signature. #{e.message}\" rescue JWT::DecodeError =&gt; e errors &lt;&lt; \"Invalid ID token. #{e.message}\" end sub = decoded_token[0][\"sub\"] alg = decoded_token[1][\"alg\"] unless sub.is_a?(String) &amp;&amp; !sub.empty? errors &lt;&lt; \"Invalid ID token. 'Subject' (sub) must be a non-empty string.\" end unless alg == ALGORITHM errors &lt;&lt; \"Invalid ID token. 'alg' must be '#{ALGORITHM}', but got #{alg}.\" end return errorsenddef decode_options { iss: ISSUER_PREFIX + FIREBASE_PROJECT_ID, aud: FIREBASE_PROJECT_ID, algorithm: ALGORITHM, verify_iat: true, verify_iss: true, verify_aud: true, }endこれで、token 検証が完了した。取得した payload 内のユーザー情報を使って、新規ユーザーの登録などができる。今後の課題 Google 公開鍵証明書を cache する 匿名認証 他のソーシャルログイン(Twitter, line など) フロントエンド側のコードリファクタ、パフォーマンス改善参考になったリソースRails 部分の検証で大変参考になった記事やソースコードは下記となる。 Ruby で Firebase の id トークンを認証に使ってみる 説明が詳しくて大変参考になった。 Rails + Next.js + Firebase Authentication で認証付きアプリを作成する ソースコードはすごく勉強になった。とりわけ参考になった Proper way to verify Firebase id tokens 認証全体の流れはパッとわかるようになったのは、こちらの issue 文の説明のおかげだ。 How to validate Firebase ID token in Ruby 同作者による詳細説明記事とソースコードも大変参考になった。 firebase-admin-sdk-ruby gem を使っていないけど、ソースコード自体が大変参考になった。 firebase-admin-python こちらは Firebase 公式の python 版 admin-sdk ソースコード。コード内のコメント説明も大変参考になった。 How to Sign and Validate JSON Web Tokens – JWT Tutorial JSON Web Token について勉強になった。 Next.js 側の実装Next.js 編はこちら -&gt; Next.js 側の実装" }, { "title": "Reactの条件付きレンダーで`&&`演算子使う時の注意点", "url": "/22/10/react-conditional-rendering/", "categories": "Coding", "tags": "JavaScript, React", "date": "2022-10-29 00:00:00 +0900", "snippet": "今朝 medium でStop Using “&amp;&amp;” for Conditional Rendering in Reactという記事を見かけた。&amp;&amp;演算子を使った条件付きレンダーはちょうど昨日の動画教材で勉強したけど、この記事はそれを使わない方が良い理由を紹介したので、補充説明としてまた勉強になった。&amp;&amp;演算子の注意点について、React 公式...", "content": "今朝 medium でStop Using “&amp;&amp;” for Conditional Rendering in Reactという記事を見かけた。&amp;&amp;演算子を使った条件付きレンダーはちょうど昨日の動画教材で勉強したけど、この記事はそれを使わない方が良い理由を紹介したので、補充説明としてまた勉強になった。&amp;&amp;演算子の注意点について、React 公式ドキュメントでも紹介があったけど、赤い文字とかで特別強調していないので、見逃されやすいかも。&amp;&amp;演算子を使った条件付きレンダーReact 公式ドキュメントでは下記の例を使っている。未読メッセージが 0 件以上なら、ユーザーに提示するという条件付きレンダーがある。unreadMessages.length &gt; 0 &amp;&amp; ( &lt;h2&gt;You have {unreadMessages.length} unread messages.&lt;/h2&gt;);ここは論理演算子の短絡評価(short-circuit evaluation)という評価法を利用している。ruby でも似たよう使い方があるので、理解が早いと思う。もし’&amp;&amp;’演算子の左の条件式が trueの場合、 右の式が必ず評価される falseの場合、右の式が評価されないなぜなら、false &amp;&amp; expressionの場合は、必ずfalseと評価して返すので、右の式を評価する必要がない。React はそれの特性を利用して、もし条件部分がtrueの場合、&amp;&amp;後ろの要素が出力される。もし条件部分がfalseなら、React は&amp;&amp;後ろの要素を無視して飛ばす。注意点ただ、&amp;&amp;演算子を使うとき、注意しなければならない点がある。それは、もし&amp;&amp;左の条件部分の評価結果は boolean 型でない場合、問題が起こること。 もし条件部分が0になった場合、0そのものが出力される。例えば、下記のcount &amp;&amp; &lt;h1&gt;Messages: {count}&lt;/h1&gt;について、countが0になる場合、JavaScript ではfalsyな値に該当し、右の式が出力されないけど、0そのものが返されるため、最終的に&lt;div&gt;0&lt;/div&gt;がレンダーされる。return &lt;div&gt;{count &amp;&amp; &lt;h1&gt;Messages: {count}&lt;/h1&gt;}&lt;/div&gt;; もし条件部分がundefinedになった場合、エラーが起こるUncaught Error: Error(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.代替案：if 文か三項演算子を使う予想外の問題を回避するため、&amp;&amp;を使うより、普通の if 文か三項演算子を使った方が良い。if (count) { &lt;h1&gt;Messages: {count}&lt;/h1&gt;;}// or 三項演算子を使うcount ? &lt;UnreadMessageコンポーネント /&gt; : null;Stop Using “&amp;&amp;” for Conditional Rendering in React記事の結論としては、&amp;&amp;より、常に三項演算子を使った方良いということ。// Bad条件式 &amp;&amp; &lt;条件付きコンポーネント /&gt;// Good条件式 ? &lt;条件付きコンポーネント /&gt; : null個人的には、三項演算子を使う場合、式が少し複雑になると、全体的に読みにくくなるので、場合によって、使い分けた方が良いと思う。参照React 条件付きレンダーStop Using “&amp;&amp;” for Conditional Rendering in React" }, { "title": "Rails 7 でReactを使う方法まとめ", "url": "/22/10/rails-7-api-reactjs/", "categories": "Coding", "tags": "Ruby on Rails, JavaScript, React", "date": "2022-10-25 00:00:00 +0900", "snippet": "Rail 7 API + React で PF を作りたいけど、関連チュートリアを探してたとき、やり方が複数あるようで、一時迷っていた。Rails 7 で react を使う方法まとめRails で React を使う方法は、下記にまとめてみた。 Rails 7 デフォルトの import-map を使って React を Rails に組み込む。 JavaScrip...", "content": "Rail 7 API + React で PF を作りたいけど、関連チュートリアを探してたとき、やり方が複数あるようで、一時迷っていた。Rails 7 で react を使う方法まとめRails で React を使う方法は、下記にまとめてみた。 Rails 7 デフォルトの import-map を使って React を Rails に組み込む。 JavaScript bundler を使って React を Rails に組み込む。 Rails 7 デフォルトの jsbundling-rails で、esbuild, rollup.js, Webpack のいずれかを使う。 webpacker を使う。(webpacker は既に開発終了) webpacker 後継の Shakapacker を使う。 ほか gem 経由で webpacker / Shakapacker を使う。(主に react-rails と react_on_rails) React アプリと Rails API サーバ をそれぞれ作る。フロントエンドとバックエンドを完全分離。 1. Rails 7 デフォルトの import-map を使うやり方については、DHH 自身による説明動画がある。Alpha preview: Using React with importmaps on Rails 7惜しいことは、React 使うなら、基本的にこの方法を使わない方が良いと思われる。なぜなら、React の特徴でもあるJSX 構文が使えないから。import-map はトランスパイルやコンパイルを経由せず、JavaScript モジュールを CDN などから直接インポートしている。なので、JavaScript へのコンパイルが必要な JSX 構文が使えない。import-map を使って、React コードを書くと、こんな感じになる。import React from \"react\";import ReactDOM from \"react-dom\";const Hello = (props) =&gt; React.createElement(\"div\", null, `Hello ${props.name}`);Hello.defaultProps = { name: \"David\",};document.addEventListener(\"DOMContentLoaded\", () =&gt; { ReactDOM.render( React.createElement(Hello, { name: \"Rails 7\" }, null), document.getElementById(\"app\") );});糖衣構文を使わず、React.createElement(component, props, ...children)そのまま書く必要。参照： How to use React with Rails 72. JavaScript bundler を使うjsbundling-rails(esbuild)、またはShakapackerを使うこの二つの違いとやり方について、下記のチュートリアを参照できる。How to Create a CRUD App with Rails and React(日本語翻訳版)Rails 7 と React による CRUD アプリ作成チュートリアルまた、 import-map、jsbundling と shakapacker の違いについて、下記の記事を参照できる。JavaScript in Rails 7Comparison with webpacker (shakapacker)react-rails / react-on-railsを使うどちらも setup が簡単で、Shakapackerをサポートしている。ちなみに、react-on-railsの開発チームはShakapackerの開発者であり、react-railsの保守もサポートしている。Rails 内で React を使うなら、こちらの gem を使うのも良いと思う。参照:react-railsreact_on_rails3. 独立した React アプリを作るこのやり方では、React と Rails との統合を考慮する必要がなく、Rails API 側はどのようなデータを返すのかを考えれば良い、そしてデータの表現や画面遷移は React 側に任せる。それぞれの役割にフォーカスできるので、個人的にこの方法が一番やりやすいと思う。完全分離するやり方について、日本語のチュートリアルは下記を参考できる。Rails と React で SPA 開発+AWS（Fargate・CloudFront）デプロイ解説チュートリアル【Rails×React】UberEats 風アプリを作りながら、SPA 開発を学ぼうただ、単純に API サーバにするなら、Rails の優位点は何なのか？という質問が自分の中で出ている…その他参照React and Ruby on Rails Integration Tips" }, { "title": "RailsのDelegated Typesで複数モデルを扱うフィード機能を作る", "url": "/22/10/rails-delegated-types-polymorphic/", "categories": "Coding", "tags": "Ruby on Rails, Database", "date": "2022-10-20 00:00:00 +0900", "snippet": "背景個人 PF でニュースフィードみたいな機能を作りたい。そのフィードで表示する情報は複数のモデルから獲得して、時間順や人気順で表示する。たとえば、Facebook のタイムラインように、友達の投稿だけでなく、誕生日の通知やアクティビティ更新、イベント情報などいろんな情報を表示する。PF ではまだ二つ種類だけの投稿を表示する予定なので、一番簡単なのは、その二つ種類の投稿モデルを一つのモデルに...", "content": "背景個人 PF でニュースフィードみたいな機能を作りたい。そのフィードで表示する情報は複数のモデルから獲得して、時間順や人気順で表示する。たとえば、Facebook のタイムラインように、友達の投稿だけでなく、誕生日の通知やアクティビティ更新、イベント情報などいろんな情報を表示する。PF ではまだ二つ種類だけの投稿を表示する予定なので、一番簡単なのは、その二つ種類の投稿モデルを一つのモデルにする方法。ただコラムが異なる部分が多いのと、今後他の情報を追加表示したいなら、また解決方法を考える必要になるので、今回でも正面から解決したいと思う。仮に今回のフィードで下記のような二つモデルを扱う予定。 投稿記事# == Schema# Table name: posts# id :integer# user_id :integer# title :string# content :text イベント情報# == Schema# Table name: events# id :integer# user_id :integer# title :string# content :text# place :string解決策調べたら、主に四つの解決策があるようで、 single table inheritance (STI、単一テーブル継承) 、 Abstract Classes(抽象クラス)、Polymorphic Association（ポリモーフィック関連）と Delegated Types(委譲型)。STI や抽象クラスなどそれぞれのデメリットがあるため、結論としては、Delegated Types が一番良い。1. STI 単一テーブル継承を使うSTI を使うと、二つのテーブルを一つの feeds テーブルに合併するようになる。# == Schema# Table name: feeds# id :integer# user_id :integer# title :string# content :text# place :string# type :string #['Post', 'Event']class Feed &lt; ApplicationRecord belongs_to :userendclass post &lt; Feed; endclass Event &lt; Feed; endデータは一つのテーブルに保存しているので、フィードで投稿とイベントを時間順で表示するのはFeed.order(created_at: :desc)で簡単にできる。ただデメリットとしては、テーブルが膨大になるし、NULL 値がいっぱい発生する。STI なら、やはり性質上が同じで、コラムもほぼ重複するようなモデルを扱う場合の方が良い。2. Abstract Classes(抽象クラス)これはモデルそれぞれのテーブルを保有して、相互間のつながりは一つの抽象ベースモデルを介して行うやり方。class Feed &lt; ApplicationRecord self.abstract_class = trueend# == Schema# Table name: posts# id :integer# user_id :integer# title :string# content :textclass Post &lt; Feed belongs_to :userend# == Schema# Table name: events# id :integer# user_id :integer# title :string# content :text# place :stringclass Event &lt; Feed belongs_to :userendこれでユニークな属性を個別のテーブルに分離することができるけど、重複するようなコラム(user, title, content)が削減できていない。それより、Feed.allなど DB クエリ操作ができないので、フィード機能自体の実現がややこしくなる。3. Polymorphic Association（ポリモーフィック関連）これは Rails ガイドで説明があり、以前使ったこともある。Rails ガイド：ポリモーフィック関連付けFeed の実装方法を検索した時、Stack Overflow で出ている回答はほとんどポリモーフィック関連を使うやり方。フィード生成用の feeds テーブルを作成して、投稿とイベントを作成するたびに、feed レコードも作成する。ビューで表示するとき、@feed.feedableで親のレコードを取得できる。# == Schema# Table name: feeds# id :integer# feedable_type :string# feedable_id :stringclass Feed &lt; ApplicationRecord belongs_to :feedable, polymorphic: trueend# == Schema# Table name: posts# id :integer# user_id :integer# title :string# content :textclass Post &lt; ApplicationRecord belongs_to :user has_many :feeds, as: :feedableend# == Schema# Table name: events# id :integer# user_id :integer# title :string# content :text# place :stringclass Event &lt; ApplicationRecord belongs_to :user has_many :feeds, as: :feedableendこれで機能自体が実現できているけど、ちょっとだけ違和感がある。一つクエリ操作でレコードを全部取得するため、新しい feeds テーブルを作ったけど、feed と post、event の間は、一対一の関係になるはずなのに、関係付けはhas_manyになっている。4. Delegated Types実は Delegated Types を実装するとき、ポリモーフィックと似たような感じで、この二つの違いを迷っていた。下記の記事のおかげで、ようやく違いが理解できた。Delegated Types in Rails, handling models with overlapping attributesポリモーフィック関連が「has many」関係のインタフェースを定義する。一方、Delegated Types は「has one」関係のインタフェースを定義する。なので、今回は Delegated Types の方が一番相応しい解決策。(Delegated Types は Rails 6.1 以降リリースの機能で、Rails 6.1 以前のバージョンが使えない。)Delegated Types は STI と抽象クラスの良いところを吸収して、一つのソリューションに融合させたもの。　　それで、共通属性を親テーブルに格納でき、独自の属性だけをそれぞれのテーブルに保存する。# == Schema# Table name: feeds# id :integer# user_id :integer# title :string# content :text# feedable_type :string# feedable_id :stringclass Feed &lt; ApplicationRecord belongs_to :user delegated_type :feedable, types: %w[Post Event]end# == Schema# Table name: posts# id :integerclass Post &lt; ApplicationRecord has_one :feed, as: :feedableend# == Schema# Table name: events# id :integer# place :stringclass Event &lt; ApplicationRecord has_one :feed, as: :feedableendFeed モデルに delegated_type :feedable を含めることで、feedable にポリモーフィックな belongs_to リレーションシップを裏で追加している。構文には少し違いがあるけど、大体は通常のポリモーフィック関連を設定するのと同じ。ただ delegated_type は一対一の関係なので、post.feed.titleで親モデルの属性を取得できる。これは一対多のポリモーフィック関連ではできない。レコードの作成も簡単になる。Feed.create( feedable: Event.create(place: \"Tokyo\"), title: \"東京もくもく会\", content: \"Rails勉強会\", user: current_user,)Rails 7 から導入されたaccepts_nested_attributes_for を利用してさらに簡単。class Feed &lt; ApplicationRecord belongs_to :user delegated_type :feedable, types: %w[Post Event] accepts_nested_attributes_for :feedableendFeed.create( feedable_type: \"Event\", title: \"東京もくもく会\", content: \"Rails勉強会\", user: current_user, feedable_attributes: { place: \"Tokyo\", },)ビューで情報表示する時、共通属性と独自属性データをそれぞれ取得する。Feed.first.feedable# &lt;Event id: 1, place: 'Tokyo'&gt;Event.first.feed# &lt;Feed id: 1, feedable_type: 'Event', feedable_id: 1,# title: '東京もくもく会', content: 'Rails勉強会', user_id: 1&gt;これで、重複するコラムと大量の NULL 値がなくなり、DB クエリでそれぞれのデータを取得できる。モデルそれぞれの振る舞いも設定できる。完璧な解決案!参照Delegated Types in Rails, handling models with overlapping attributesActiveRecord::DelegatedType(Rails API ドキュメント)Feed from multiple models (sorted by the time they were added to the feed)単一テーブル継承(STI)についてRails: ActiveRecord::DelegatedType API ドキュメント（翻訳）" }, { "title": "Chromeが第三者アプリからのリンクを開けない状況について", "url": "/22/10/chrome-external-link-open/", "categories": "Others", "tags": "Mac, Chrome", "date": "2022-10-02 00:00:00 +0900", "snippet": "問題背景Mac でデフォルトブラウザを Google Chrome に設定している。Chrome 自体はいつも普通に使えるけど、最近は、Docker や Discord など第三者アプリ内のリンクをクリックしたら、chrome が反応しないことに気がついた。デフォルトブラウザを Safari に変更したら、リンクは問題なく Safari から開けた。##　原因調べたら、Chrome が外部リ...", "content": "問題背景Mac でデフォルトブラウザを Google Chrome に設定している。Chrome 自体はいつも普通に使えるけど、最近は、Docker や Discord など第三者アプリ内のリンクをクリックしたら、chrome が反応しないことに気がついた。デフォルトブラウザを Safari に変更したら、リンクは問題なく Safari から開けた。##　原因調べたら、Chrome が外部リンクを拒否するようになった原因は、新しいバージョンのアップデートが正常に完了していないことだそう。Chrome は通常バックグランドで新しいバージョンを自動ダウンロードしておく。そしてブラウザが再起動する時、自動的にアップデートを完了する。しかし、もしブラウザがいつも開けたままで、再起動にならない時は、自動アップデートの実行ができなくて、chrome がおかしくなり、外部リンクを拒否するようになる。解決策chrome の設定ページから最新のアップデートを完了させ、chrome を再起動したら、通常通りに動ける。参照Google Chrome won’t open links anymore? Here the solution!" }, { "title": "VSCodeでReact JSX内のhtmlタグを自動補完する", "url": "/22/09/vscode-react-html-autocomplete/", "categories": "Coding", "tags": "JavaScript, React", "date": "2022-09-30 00:00:00 +0900", "snippet": "VSCode で React の JSX コードを書いている時、HTML タグの自動補完機能が効かなくなっているので、設定方法を調べてみた。方法 1：VSCode の Emmet 設定でInclude Lanuguagesを追加するVSCode の設定(setting)を開き、Include Lanuguagesで検索したら、設定画面が出てくる。Add Itemで Item 枠にjavasc...", "content": "VSCode で React の JSX コードを書いている時、HTML タグの自動補完機能が効かなくなっているので、設定方法を調べてみた。方法 1：VSCode の Emmet 設定でInclude Lanuguagesを追加するVSCode の設定(setting)を開き、Include Lanuguagesで検索したら、設定画面が出てくる。Add Itemで Item 枠にjavascript、Value 枠にjavascriptreactと追加すれば OK。(よく見たら、erb と ruby が先に自動追加されたようだ。だから rails で erb ファイルを使っている時、HTML タグが自動補完できて、不便を感じなかったかな。)方法 2：直接settings.jsonファイルで追加設定する設定内容自体は方法 1 と同じになる。VSCode の設定画面の右上アイコンから、settings.jsonファイルを開き、下記の設定コードを追加する。\"emmet.triggerExpansionOnTab\": true,\"emmet.includeLanguages\": { \"javascript\": \"javascriptreact\"}方法 3：右下の言語タブで言語モードを変更するVSCode 右下の言語タブを開き、Language Mode(言語モード)をJavaScriptからJavaScript Reactに変更する。参照JSX or HTML autocompletion in Visual Studio Code" }, { "title": "ReactのためのJavaScript簡単まとめ", "url": "/22/09/modern-javascript-cheetsheet/", "categories": "Coding", "tags": "JavaScript, React", "date": "2022-09-29 00:00:00 +0900", "snippet": "UdemyでReactコースを勉強し始めて、最初からReactでよく使うJavascriptの新機能について紹介があったので、Javascriptの復習としてメモする。変数宣言 var / const / let結論：基本的にconstを使う。varを使わない。一度宣言した変数を後から再代入する必要がある場合は、letを使う。例：const name = 'Mike';name = 'Nic...", "content": "UdemyでReactコースを勉強し始めて、最初からReactでよく使うJavascriptの新機能について紹介があったので、Javascriptの復習としてメモする。変数宣言 var / const / let結論：基本的にconstを使う。varを使わない。一度宣言した変数を後から再代入する必要がある場合は、letを使う。例：const name = 'Mike';name = 'Nick' // エラーが起こる。constで宣言する変数は再代入不可。let name = 'Mike';name = 'Nick' // letで宣言する変数は再代入可能。アロー関数通常のfunction関数宣言構文より、アロー関数のメリットは、 構文がより簡潔 thisのスコープは周りと一致する 暗黙的な return例：// 従来の書き方function callMe(name) { console.log(name);}//アロー関数const callMe = (name) =&gt; { console.log(name);}// 引数が一個のみの場合、引数の括弧が省略できるconst callMe = name =&gt; { console.log(name);}// 単純に値を返す場合、returnを省略できる const double = x =&gt; x * 2;// returnを明記する書き方 const double = (x) =&gt; { return x * 2; }Exports &amp; Imports**2種類のexports: ** default exports：モジュールごとにひとつだけdefault exportが指定できるconst person = { name: 'Max'}export default person 他のファイルでimportする時、任意の名前でimportできる// 元の名前でimportimport person from './person.js'// 任意の名前でimport、例えば peopleimport people from './person.js' named exports(名前付きエクスポート):export const clean = () =&gt; {...}export const baseData = 10;他のファイルでimportする時、名前通りにimportする必要import { clean, baseData } from './utility.js'// 新しい名前でエイリアス設定可能import { baseData as data } from './utility.js'// まとめてimport可能import * as utilities from './utility.js'consoloe.log(utilities.baseData) // 10Classesオブジェクト指向の言語でのclassと似ている。extendsでクラスの継承もできる。class Human { constructor() { this.age = 30; // `this`はrubyやpythonの中の`self`のような感じ？ } printMyAge() { console.log(this.age) }}class Person extends Human { constructor() { super(); // 親クラスのconstructorが呼ばれる this.name = 'Max'; this.age = 20; //属性のオーバライドできる } printMyName() { console.log(this.name) }}const person = new Person();person.printMyName; // Maxperson.printMyAge; // 20ES7以降の仕様はconstructorが不要になるので、もっと簡潔にできるclass Human { age = 20;} class Person extends Human { name = 'Max'; printMyName = () =&gt; { console.log(this.name); }} const person = new Person();person.printMyName(); // Maxconsole.log(person.age); // 20Spread / Rest Operator “...”...演算子を使って、配列やオブジェクトなどを簡単に分割/複製できるconst numbers = [1, 2, 3];const newNumbers = [...numbers, 4, 5]; console.log(newNumbers); // [1, 2, 3, 4, 5]const person = { name: 'Max'};const newPerson = { ...person, age: 20}/* newPersonの中身 =&gt;{ name: 'Max', age: 28}*/...はレスト演算子として、関数の引数をまとめて配列に入れ込むことができる。const filter = (...args) =&gt; { return args.filter(number =&gt; number &gt;= 2);}console.log(filter(1, 2, 3)) // [2, 3]オブジェクトや配列の分割(Destructuring)// 配列を分割するconst array = [1, 2, 3];const [num1, num2] = array;console.log(num1, num2); // 1 2// 中に空のスペースを入れるとconst [num1, , num3] = [1, 2, 3];console.log(num1, num3); // 1 3// オブジェクトを分割するconst myObj = { name: 'Max', age: 28}const {name} = myObj;console.log(name); // Maxconsole.log(age); // undefinedconsole.log(myObj); // {name: 'Max', age: 28}Primitive / Reference Data Types基本型と参照型は新しい概念ではないけど、よく忘れる重要な概念なので、一旦メモする。基本型データ：numbers, strings, booleans, null, undefinedなど参照型データ：Arrays, Objects, Functions, Collections, Datesなどこの二つのデータ型の違いはデータの保存形式になる。基本型例：let number = 1; let num2 = number;number = 2console.log(number) // 2console.log(num2) // 1const num2 = numberは変数numberの値「1」をコピーして変数num2に渡す。変数numberと変数num2はそれぞれの独立の値を持ち、メモリ空間でそれぞれの値を格納する。そのため、numberの値を変更しても、num2には影響がない。参照型例：const person = { name: 'Max'};const secondPerson = person; secondPerson.name = 'John'console.log(person.name); // Johnconst person = {..}でpersonは独立のオブジェクトを持つのではなく、メモリに格納するのは{ name: 'Max' }というオブジェクトだけ。変数personが保存するのは{ name: 'Max' }オブジェクトが格納された場所を指すポインター。ポインターというのは、そのオブジェクトが格納された場所(メモリのアドレス)を保存するもの。const secondPerson = psersonで、新しい{ name: 'Max' }オブジェクトを作るのではなく、先作ったオブジェクトのアドレスをコピしてポインターとしてsecondPersonに渡すだけ。そのため、secondPerson.nameを変更したら、secondPersonが指すオブジェクト{ name: 'Max' }自体を{ name: 'John' }に変更することになるので、同じオブジェクトを指すpersonの中身も変更になる。...演算子を使うと、オブジェクトをコピできる通常の参照型データと違って、...演算子を使うと、オブジェクトそのものをコピーできるconst person = { name: 'Max'};const secondPerson = { ...person}person.name = 'John';console.log(secondPerson.name); // 'Max'ここでsecondPersonが持つのは、ポインターではなく、{ name: ‘Max’ }オブジェクト自体をコピーして、独立したオブジェクト。そのため、person.name = 'John'で元のオブジェクトを変更しても、コピしたオブジェクトには影響はない。配列でよく使う関数 map(), filter(), reduce()map()配列内の要素を全部呼び出して、その結果を新しい配列として生成する。const array1 = [1, 4, 9, 16];const map1 = array1.map(x =&gt; x * 2);console.log(map1); // [2, 8, 18, 32]filter()条件を満たす要素を抽出して新しい配列を生成する。const nums = [1,2,3,4,5,6]console.log(nums.filter(num =&gt; num &gt; 3)) // [4, 5, 6]reduce()配列内に対して関数を適用し、その処理によって配列の要素を(左から右に)一つの値にまとめるconst nums = [1,2,3]let initValue = 0;const sumNumbers = nums.reduce( (prev, curr) =&gt; prev + curr, initValue);console.log(sumNumbers); // 6 &lt;= 0+1+2+3initValue = 2;const multiplyNumbers = nums.reduce( (prev, curr) =&gt; prev * curr, initValue)console.log(multiplyNumbers); // 12 &lt;= 2*1*2*3参照React - The Complete Guide (incl Hooks, React Router, Redux)モダン JavaScript チートシート" }, { "title": "Readable Codeメモ：メソッド名や変数名を正しく選ぶ", "url": "/22/09/readable-code-choose-names/", "categories": "Coding", "tags": "Better Code, Refactor, Reading Notes", "date": "2022-09-20 00:00:00 +0900", "snippet": "読みやすさの基本定理とは コードは他の人が最短時間で理解できるように書かなければいけない。第二章：名前に情報を詰め込む1. 明確な単語を選ぶメソッド名や変数名は曖昧な単語を使うより、類語辞典を使って、カラフルな単語を選んだ方良い。例： GetPage -&gt; FetchPage, DownloadPage Stop() -&gt; Kill(), Resume(), Pause()...", "content": "読みやすさの基本定理とは コードは他の人が最短時間で理解できるように書かなければいけない。第二章：名前に情報を詰め込む1. 明確な単語を選ぶメソッド名や変数名は曖昧な単語を使うより、類語辞典を使って、カラフルな単語を選んだ方良い。例： GetPage -&gt; FetchPage, DownloadPage Stop() -&gt; Kill(), Resume(), Pause() sendの類語: deliver, dispatch, announce, distribute, route findの類語: search, extract, locate, recover startの類語: launch, create, begin, open makeの類語: create, set up, build, generate, compose, add, new2. tmpやretvalなど汎用的な名前を避けるentityの値や目的を表す名前を選ぶ。ループイテレータに関しては、通常はi, j, kなどを使うが、複雑な場合は club_i, members_iか, 短縮でclubs[ci], members[mi]で使う。3. 抽象的な名前より具体的な名前を使うdisallow_evil_constructorsよりは、もっと明確的に、disallow_copy_and_assignを使った方が良いServerCanStart()より、CanListenOnPort()の方が明確的。4. 名前に大切な情報を追加する例： 16進数の文字列を持つ変数名：hex_id 値の単位を入れる： ミリ秒を表す変数名に_msつける これからエスケープ必要な変数名に raw_をつける size → size_mb, limit → max_kbps 危険や注意を喚起する重要な属性を入れる untrustedUrl, unsafeMessageBody, plaintext_password, unescaped_comment html_utf8：htmlの文字コードをUTF-8に変えた data_urlenc： 入力されたdataをURLエンコードした5. 名前の長さを決める：スコープが小さければ短い名前でもいい6. 名前のフォーマットで情報を使える例： クラス名はCamelCase形式, 変数名はlower_separated形式 HTMLのidの区切り文字はアンダースコア id=”middle_column” classの区切り文字はハイフン、class=”main-content”第3章：誤解されない名前1. 例：filter()results = Database.all_objects.filter(”year ≤ 2011”)resultsは2011以前のオブジェクトなのか、2011年以降なのか、ちょっと曖昧で、もっと明確にするなら、select()か、exclude()にする2. 例：Clip(text, length)段落の内容を切り抜く関数 Clip(text, length)最後からlength文字を削除するか(remove)、最大length文字まで切り詰めるか(truncate)、また曖昧。もしTruncate(text, length)にするなら、lengthはmax_lengthにした方良いさらに、lengthはバイト数か、文字数か、単語数か、これも明確にする改善後：Truncate(text, max_chars)3. 限界値を含めるときはmin/ max使う4. 範囲を指定するときはfirst, last使う5. 包含・排他的範囲にはbegin/end使う6. Boolean値の名前ブール値の変数名は is, has, can, shouldなどをつける※rubyだと、末尾に?を付ける方法がある。read_password = ture -&gt; need_password, user_is_authenticated否定形を避ける: disable_ssl = false -&gt; use_ssl = true7. ユーザーの期待に合わせる単語を別の意味で使っていたとしても、ユーザーが先入観を持っているため、誤解を招いてしまうことがある。例えば、get()やsize()など軽量なメソッドとして期待されている。 例：getMean()ここのgetMean()は過去のデータを全てイテレートして、その場で平均値を計算するメソッド。getで始まるメソッドは通常なら軽量アクセスという規約があるけど、ここで使うメソッドは大量計算コストがかかる。その計算コストがかかることを知らないメンバーだと、思わずにgetMean()を呼び出してしまう可能性がある。そういう誤解を避けるため、computeMean()を使った方良い。 例：list::size()void ShrinkList(list&lt;Node&gt;&amp; list, int max_size) {\twhile (list.size() &gt; max_size) {\t\tFreeNode(list.back());\t\tlist.pop_back();ここのlist.size()はLinked Listのノード数を事前計算せずに順番にカウントしているので、計算量はO(n)になっている。それでShrinkList()全体の計算量はO($n^2$)になっている。元々size()という名前は暗黙の計算量はO(1)なので、誤解されないようにするため、この場合は、countSize()やcountElement()にした方が良い。参照リーダブルコード ―より良いコードを書くためのシンプルで実践的なテクニック" }, { "title": "Capybaraでheadless_chromeのスクリンサイズを設定する", "url": "/22/09/capybara-chrome-screen-size/", "categories": "Coding", "tags": "RSpec, Ruby on Rails, Test, Capybara, Chrome", "date": "2022-09-19 00:00:00 +0900", "snippet": "背景RSpec でシステムテストする時、ログインボタンが見つからないエラーが報告された。chrome を下記のように headless に設定している。RSpec.configure do |config| config.before(:each, type: :system) { driven_by :selenium_chrome_headless }endエラーキャプチャを見たら、確...", "content": "背景RSpec でシステムテストする時、ログインボタンが見つからないエラーが報告された。chrome を下記のように headless に設定している。RSpec.configure do |config| config.before(:each, type: :system) { driven_by :selenium_chrome_headless }endエラーキャプチャを見たら、確かにあるはずのログインボタンのところに空白と表示されている。それより、ヘッダー部分全体もほとんど表示されていない。そして、一旦 chrome の headless を外して、もう一回テスト実行すると、無事通った。エラー原因最初は画面で何かエラーが出たか、または CSS 設定の問題かと思ったので、headless 外した状態でデバッグしてみた。すると、偶然に chrome の画面サイズが小さくなっていることに気がついた。chrome のサイズを大きくすると、消えていたヘッダー部分が通常表示するようになる。chorome_headless の状態は、画面サイズが 800x600 程度小さくなるけど、headless 外した時、フルサイズで実行しているようだ。だから最初はログインボタンを含めヘッダー部分が画面に表示されていなかった。解決策chrome のスクリンサイズを大きく設定すると、問題解決になる。driven_by :selenium, using: :headless_chrome, screen_size: [1400, 1400]元々どこかで上記の書き方を見たことがあるけど、単純に書き方が違うか、と思っただけで、screen_size を指定する理由を深く考えなかった。今後デフォルトで、chrome スクリンサイズを指定するようにする。参照Chrome 83 + rspec-rails で画面サイズを変える方法" }, { "title": "RSpecでdeliver_laterのメールをテストする方法", "url": "/22/09/rspec-mailer-test-deliver-later/", "categories": "Coding", "tags": "RSpec, Ruby on Rails, Test", "date": "2022-09-18 00:00:00 +0900", "snippet": "背景RSpec でメール送信をテストする時、メールを確認できなかった。色々検索したら、deliver_laterの影響だと気づいた。解決案いろいろ試して、上手く行けたのは下記の二つ方法1. have_enqueued_mail　 matcher を使う一番簡単な方法はhave_enqueued_mail　 matcher を使って、メールが実行待ち行列に入っていることを確認する。先にActi...", "content": "背景RSpec でメール送信をテストする時、メールを確認できなかった。色々検索したら、deliver_laterの影響だと気づいた。解決案いろいろ試して、上手く行けたのは下記の二つ方法1. have_enqueued_mail　 matcher を使う一番簡単な方法はhave_enqueued_mail　 matcher を使って、メールが実行待ち行列に入っていることを確認する。先にActiveJob::Base.queue_adapter = :testを追加する必要。RSpec.describe UserMailer do it \"matches with enqueued mailer\" do ActiveJob::Base.queue_adapter = :test expect { UserMailer.signup.deliver_later }.to have_enqueued_mail( UserMailer, :signup, ) endend配信予定時間を含めての確認も簡単RSpec.describe UserMailer do it \"matches with enqueued mailer\" do ActiveJob::Base.queue_adapter = :test expect { UserMailer.signup.deliver_later(wait_until: Date.tomorrow.noon) }.to have_enqueued_mail.at(Date.tomorrow.noon) endend2. perform_enqueued_jobsメソッドを使うもしメールの内容まで確認必要だったら、ActiveJob::TestHelperモジュールが用意するperform_enqueued_jobsメソッドを使って、deliver_laterのメール配信ジョブをすぐ実行させる。RSpec.describe UserMailer do include ActiveJob::TestHelper it \"matches mail result\" do perform_enqueued_jobs(only: ActionMailer::MailDeliveryJob) do expect(UsersMailer.signup.deliver_later).to change( ActionMailer::Base.deliveries, :count, ).by(1) mail = ActionMailer::Base.deliveries.last expect(mail.subject).to eq \"mail subject\" end endend先にActiveJob::TestHelperモジュールを include するのが必要。メールオブジェクトはActionMailer::Base.deliveries.lastを使って取得する。全てのジョブを有効にすると、効率が悪くなるので、MailDeliveryJobに限定した方良い。参照(ActionMailer の deliver_later でメール送信する場合のユニットテストの書き方Have_enqueued_mail matcherperform_enqueued_jobs" }, { "title": "Capybaraでfontawesomeのiconリンクをテストする", "url": "/22/09/capybara-css-icon-test/", "categories": "Coding", "tags": "RSpec, Ruby on Rails, Test, Capybara, CSS, Fontawesome", "date": "2022-09-17 00:00:00 +0900", "snippet": "背景仮にブログ対してのブックマーク機能をテストする。ブックマーク関係の erb ファイル内容は下記で&lt;div id=\"js-blog-bookmark-&lt;%= blog.id %&gt;\"&gt; &lt;% if current_user.bookmarked?(blog) %&gt; &lt;%= render 'blogs/bookmarks/unbookmark'...", "content": "背景仮にブログ対してのブックマーク機能をテストする。ブックマーク関係の erb ファイル内容は下記で&lt;div id=\"js-blog-bookmark-&lt;%= blog.id %&gt;\"&gt; &lt;% if current_user.bookmarked?(blog) %&gt; &lt;%= render 'blogs/bookmarks/unbookmark', blog: blog %&gt; &lt;% else %&gt; &lt;%= render 'blogs/bookmarks/bookmark', blog: blog %&gt; &lt;% end %&gt;&lt;/div&gt;&lt;%= link_to blog_bookmark_path(blog), remote: true, method: :post do %&gt; &lt;i class=\"bi bi-star\"&gt;&lt;/i&gt;&lt;% end %&gt;&lt;%= link_to blog_bookmark_path(blog), remote: true, method: :delete do %&gt; &lt;i class=\"bi bi-star-fill\"&gt;&lt;/i&gt;&lt;% end %&gt;生成する HTML ファイルは下記となる ブックマーク icon クリック前# blog_idが1のブログ&lt;div id=\"js-blog-bookmark-1\"&gt; &lt;a data-remote=\"true\" rel=\"nofollow\" data-method=\"post\" href=\"/blogs/1/bookmark\" &gt; &lt;i class=\"bi bi-star\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/div&gt; ブックマーク icon クリックした後# blog_idが1のブログ&lt;div id=\"js-blog-bookmark-1\"&gt; &lt;a data-remote=\"true\" rel=\"nofollow\" data-method=\"delete\" href=\"/blogs/1/bookmark\" &gt; &lt;i class=\"bi bi-star-fill\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/div&gt;capybara でのテスト方法まずは一番目のブログのブックマーク icon をクリックする(任意のブログでも良いけど)find(\"#js-blog-bookmark-#{blog.id}\").find(:css, \"i.bi.bi-star\").clickブックマークされた icon の表示を確認する 方法 1: have_cssを使うexpect(page).to have_css \"i.bi.bi-star-fill\" 方法 2: has_css?メソッドを使うexpect(has_css?(\"i.bi.bi-star-fill\", count: 1)).to eq true 方法 3: withinメソッドを使うwithin(\"#js-blog-bookmark-#{blog.id}\") do expect(page).to have_css \"i.bi.bi-star-fill\"endこれで、特定のブログがブックマークされたかどうかを確認できる補足：icon をクリックする方法について、直接リンクに class や id、title をつけて icon をクリックするのも一つの方法。html 部分が下記に修正する&lt;div id=\"js-blog-bookmark-1\"&gt; &lt;a class=\"bookmark-link\" title=\"Create bookmark\" data-remote=\"true\" rel=\"nofollow\" data-method=\"post\" href=\"/blogs/1/bookmark\" &gt; &lt;i class=\"bi bi-star\"&gt;&lt;/i&gt; &lt;/a&gt;&lt;/div&gt;そうすると、下記のようにクリックできる# ブックマークiconが複数存在する場合、一番目に指定find_link(\"Create bookmark\", match: :first).click# ブックマークiconが一つのみの場合find_link(\"Create bookmark\").click一つ目の要素を指定する方法についてちなみに、一つ目の要素を指定する方法としては、下記の中に、matchを使った方が良いだそう。find(\".my-selector\", match: :first)# orall(\".my-selector\").first# orfirst(\".my-selector\")なぜなら、matchを使うと、capybara がマッチする要素が少なくとも一つが現れるまで待ってくれる。参照Test css(icon) in CapybaraRspec Target Font Awesome Icon LinkCapybara: click on element found by the icon classCapybara - select first element (Ambiguity Resolution)" }, { "title": "Tailwindとsassの非互換問題の解決について", "url": "/22/09/tailwind-sass-incompatible-error/", "categories": "Coding", "tags": "Ruby on Rails, css, tailwind, sass", "date": "2022-09-07 00:00:00 +0900", "snippet": "今回のエラーはGithub Actionsを使ったCI環境で出たエラー。背景には、Tailwindとsassの非互換問題(incompatible)があることがわかった。背景Tailwindcss-railsの公式説明によると、TailwindがモダンなCSS構文を使っているけど、Sassが最新のCSS構文をまだ理解できていないため、アセットパイプラインでtailwindのcss構文をsas...", "content": "今回のエラーはGithub Actionsを使ったCI環境で出たエラー。背景には、Tailwindとsassの非互換問題(incompatible)があることがわかった。背景Tailwindcss-railsの公式説明によると、TailwindがモダンなCSS構文を使っているけど、Sassが最新のCSS構文をまだ理解できていないため、アセットパイプラインでtailwindのcss構文をsassc-rails経由で圧縮したら、SassC::SyntaxErrorというエラーが出てしまう。tailwindを使うには、gem sassc-rails をアンインストールするのが必要だ。エラー例：SassC::SyntaxError: Error: Function rgb is missing argument $green. on line 1 of stdin&gt;&gt; -white{--tw-bg-opacity:1;background-color:rgb(255 255 255/var(--tw-bg-opacity));ここのrgb(255 255 255/var(--tw-bg-opacity))、つまりrgb(0 0 0 / 0%)形式の構文は最新のCSS構文で、通常の形式なら、rgb(0, 0, 0)か、rgba(0, 0, 0, 0)にする必要。Tailwindcss-railsの公式説明 Tailwind uses modern CSS features that are not recognized by the sassc-rails extension that was included by default in the Gemfile for Rails 6. In order to avoid any errors like SassC::SyntaxError, you must remove that gem from your Gemfile.https://github.com/rails/tailwindcss-rails#conflict-with-sassc-railsしかし、今回のRails7アプリは、管理画面はrails-adminを使って構築した。rails-adminがまだSassに依存しているので、sassc-railsを削除したら、 cannot load such file -- sasscエラーが出る。解決方法tailwindとsassを同時に使うため、CSS Compressorはsassでなく、別のモダンなcompressor(今回はCSSO)をカスタマイズして使用すること。 csso-cliをインストールyarn add csso-cli config/initializers/csso.rbファイルを新規作成して、カスタムcompressor作成 require \"open3\"class CssoCompressor def self.call(input) puts \"[CssoCompressor] Compressing…\" # Copy the contents of the CSS file to a temp file temp_file = Tempfile.new([input[:name], \".css\"]) temp_file.open temp_file.write(input[:data]) temp_file.flush # Run the compressor and capture the output css, err, status = Open3.capture3(\"npx\", \"csso\", temp_file.path) {data: css} endendRails.application.config.assets.configure do |env| env.register_compressor \"text/css\", :csso, CssoCompressorend CSS Compressorを:cssoに設定するconfig.assets.css_compressor = :cssoCI環境でも使うため、config/environments/下のproduction.rbとtest.rb両方設定必要設定参照：create a custom compressor by domchristie また、CI環境でtestを実行する前に、precompile assetsのstepを追加する必要。# Precompile assets- name: Assets Precompile run: bundle exec rake assets:precompile# Add or replace test runners here- name: Run tests run: bundle exec rspecじゃないと、AssetNotFoundエラーが出る。 ActionView::Template::Error: The asset \"tailwind.css\" is not present in the asset pipeline.これでtailwindとsassの非互換問題が無事解決!ちなみに、Rails7からはSass自体が非推奨になったようで、sassはなるべく使わない方が良いかも。Rails6でデフォルトでインストールされていたgem 'sassc-rails'がRails7からデフォルトでコメントアウトされている。 Modern web applications are more likely than not to use a CSS framework like Tailwind, Bootstrap, or Bulma. Rails shouldn’t be generating per-model stylesheets as though we were still writing everything by hand. Also, Sass has chosen to focus exclusively on dart-sass, which requires all manner of dependencies that Rails won’t adopt by default. So decrease our reliance on Sass, and move it to being an optional extra.by DHH氏 Remove default reliance on Sass and CSS generators #43110ほか参照：assets:precompile results in LoadError: cannot load such file – sasscHeroku Issue: ActionView::Template::Error (The asset “tailwind.css” is not present in the asset pipeline.”)" }, { "title": "Javascript処理を挟むテストの場合、Capybaraを待たせる必要", "url": "/22/09/ajax-capybara-rspec-sleep/", "categories": "Coding", "tags": "RSpec, Ruby on Rails, Test, Capybara, JavaScript", "date": "2022-09-04 00:00:00 +0900", "snippet": "状況ローカルや本番で問題なく動いているけど、RSpec テストが通ったり、通れなかったりする状況があった。test log を確認したところ、個別 example の動きがおかしくなったりしている。Started POST \"/questions/1/answer?result=good\" for 127.0.0.1 at 2022-09-02 23:25:25 +0900Processin...", "content": "状況ローカルや本番で問題なく動いているけど、RSpec テストが通ったり、通れなかったりする状況があった。test log を確認したところ、個別 example の動きがおかしくなったりしている。Started POST \"/questions/1/answer?result=good\" for 127.0.0.1 at 2022-09-02 23:25:25 +0900Processing by QuestionsController#answer as TURBO_STREAM Parameters: {\"result\"=&gt;\"good\", \"id\"=&gt;\"1\"}ここは、/questions/2/answer へ遷移すべきだけど、なぜか controller が受け取ったparams[:id]が1になっているそのせいで、テストが失敗したかもと推測。なんで parameter が正確に送られていないだろう、その原因が分からなくて、一時詰まってた。原因チームメンバと相談して、ようやくテストが失敗する原因を特定できた。Rails 7 はデフォルトで ajax で画面遷移を行なっているため、たまに capybara が ajax 処理が完了するまで待たなくて、前の画面でテストを先に処理してしまった。そのせいで、前の画面で取得したオブジェクト ID を controller に送ってしまった。対策次の画面操作する前に、capybara をちょっとだけ待たせることで、テストが問題なく通った。capybara を待たせる方法は主に二つあるそうで、 sleepを使って、capybara を一時停止させるclick_on '次の質問'sleep 1 # capybaraを1秒間sleepさせるclick_on '次の操作ボタン' ただsleepを大量使用する場合、テスト実行効率が非常に悪くなるので、代わりにfindやhave_xx句を使って、遷移後の画面にあるべき要素を確認する処理を入れることで、capybara が自動的に画面遷移の処理が完了するまで待ってくれる。デフォルトの待ち時間が最大 2 秒。とにかくsleepさせるよりは、二つ目の方がより賢い。click_on '次の質問'expect(page).to have_content \"次の画面タイトル\"click_on '次の操作ボタン'参照:テストが失敗する場合は sleep 等でテストを停止させてみるRSpec の sleep 処理について" }, { "title": "insert_allやupdate_allを使って、SQLクエリの発行を削減する", "url": "/22/09/refactor-reduce-sql-query/", "categories": "Coding", "tags": "Ruby on Rails, SQL, Database", "date": "2022-09-02 00:00:00 +0900", "snippet": "今回は東京都知事杯ハッカソンに参加して、二日間のチームワークの下で、なんと投票マッチングアプリのMVPが出来上がった。ただ、小さいアプリだけどめっちゃSQL走っていると気がついたので、もっと改善できないかなと思った。コード全体をもう一度整理して、特にSQL大量発行する箇所に目を留めた。 ユーザーと政党テーブル、質問テーブルを紐付けるところ ユーザーの選択回答を保存するところ 政党ポイン...", "content": "今回は東京都知事杯ハッカソンに参加して、二日間のチームワークの下で、なんと投票マッチングアプリのMVPが出来上がった。ただ、小さいアプリだけどめっちゃSQL走っていると気がついたので、もっと改善できないかなと思った。コード全体をもう一度整理して、特にSQL大量発行する箇所に目を留めた。 ユーザーと政党テーブル、質問テーブルを紐付けるところ ユーザーの選択回答を保存するところ 政党ポイントを計算するところ 政党マッチング結果一覧を表示するところ以上の箇所について、 紐付けるタイミングを変更できないか、まだ必要のない紐付けだったら一旦保留したら？ 紐付けは個々のレコードではなく、一括でできないか? レコードのupdateは個別で行うより、一括で更新できないか? 計算ロジックは、個々の政党レコードを取得して、一つ一つ比較して計算するよりは、二つグループに分けて一括更新するのが可能か?と考えながら、コードを書き直してみた。結果的に、全体的なSQLクエリ発行はほぼ8割程度削減できた！修正前後の比較ユーザーと政党の紐付け元々のコードはeachメソッドを使って、政党レコードを一つ一つ取得して、中間テーブルのレコードを新規作成する形式で、政党の数分でSQL文が発行される。 def create_party_relation parties = Party.all parties.each do |party| UserParty.create!(user_id: self.id, party_id: party.id, point: 0) end end 修正前SQLクエリ発行状況Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" ↳ app/models/user.rb:17:in `party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 1], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.5ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 1], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:53.973751\"], [\"updated_at\", \"2022-09-01 13:19:53.973751\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.7ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.2ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 2], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 2], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:53.983360\"], [\"updated_at\", \"2022-09-01 13:19:53.983360\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.4ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 3], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:53.989469\"], [\"updated_at\", \"2022-09-01 13:19:53.989469\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.4ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.2ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.4ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 4], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 4], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:53.998626\"], [\"updated_at\", \"2022-09-01 13:19:53.998626\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.5ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.2ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 5], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.4ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 5], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:54.005710\"], [\"updated_at\", \"2022-09-01 13:19:54.005710\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.5ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 6], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 6], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:54.012852\"], [\"updated_at\", \"2022-09-01 13:19:54.012852\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.5ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 7], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 7], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:54.019201\"], [\"updated_at\", \"2022-09-01 13:19:54.019201\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.4ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 8], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.4ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 8], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:54.026128\"], [\"updated_at\", \"2022-09-01 13:19:54.026128\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.4ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:18:in `block in party_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 9], [\"LIMIT\", 1]] ↳ app/models/user.rb:18:in `block in party_relation' UserParty Create (0.3ms) INSERT INTO \"user_parties\" (\"user_id\", \"party_id\", \"point\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 70], [\"party_id\", 9], [\"point\", 0], [\"created_at\", \"2022-09-01 13:19:54.033751\"], [\"updated_at\", \"2022-09-01 13:19:54.033751\"]] ↳ app/models/user.rb:18:in `block in party_relation' TRANSACTION (0.5ms) COMMIT ↳ app/models/user.rb:18:in `block in party_relation'改善後のやり方はpluckを使って、政党IDを一括取得して、｀user.user_parties｀の中身となるデータを配列形式で一括生成する。そしてinser_allメソッドを使ってUserPartyテーブルに一括挿入DBへ挿入する。これでSQLクエリが一回で済む。 def create_party_relation record_array = Party.pluck(:id).map { |party_id| { user_id: self.id, party_id: party_id, point: 0 } } UserParty.insert_all(record_array) end 修正後SQLクエリ発行状況Party Pluck (0.2ms) SELECT \"parties\".\"id\" FROM \"parties\" ↳ app/models/user.rb:14:in `create_party_relation' UserParty Bulk Insert (1.1ms) INSERT INTO \"user_parties\" (\"user_id\",\"party_id\",\"point\",\"created_at\",\"updated_at\") VALUES (60, 1, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 2, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 3, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 4, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 5, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 6, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 7, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 8, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP), (60, 9, 0, CURRENT_TIMESTAMP, CURRENT_TIMESTAMP) ON CONFLICT DO NOTHING RETURNING \"id\" ↳ app/models/user.rb:15:in `create_party_relation'ユーザーと質問の紐付け元々ゲストユーザーが作成された時点で、ユーザーを全部の質問と紐付けるというやり方だったけど、そもそも最初から全部の質問と紐づける必要があるのか、と疑問に感じた。もし今後ユーザーが質問をskipする機能を追加したら、その質問と紐づける自体も必要がなくなる。元々のコード# ユーザーと全部の質問を紐付けるつもり def question_relation questions = Question.all questions.each do |question| UserQuestion.create!(user_id: self.id, question_id: question.id) end endこれも質問の数分でSQLクエリが発行される。 修正前SQLクエリ発行状況 Question Load (0.2ms) SELECT \"questions\".* FROM \"questions\" ↳ app/models/user.rb:24:in `question_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:25:in `block in question_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 69], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' Question Load (0.1ms) SELECT \"questions\".* FROM \"questions\" WHERE \"questions\".\"id\" = $1 LIMIT $2 [[\"id\", 2], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' UserQuestion Create (0.5ms) INSERT INTO \"user_questions\" (\"user_id\", \"question_id\", \"result\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 69], [\"question_id\", 2], [\"result\", nil], [\"created_at\", \"2022-09-01 13:16:31.900255\"], [\"updated_at\", \"2022-09-01 13:16:31.900255\"]] ↳ app/models/user.rb:25:in `block in question_relation' TRANSACTION (40.2ms) COMMIT ↳ app/models/user.rb:25:in `block in question_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:25:in `block in question_relation' User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 69], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' Question Load (0.2ms) SELECT \"questions\".* FROM \"questions\" WHERE \"questions\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' UserQuestion Create (0.4ms) INSERT INTO \"user_questions\" (\"user_id\", \"question_id\", \"result\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 69], [\"question_id\", 3], [\"result\", nil], [\"created_at\", \"2022-09-01 13:16:31.955346\"], [\"updated_at\", \"2022-09-01 13:16:31.955346\"]] ↳ app/models/user.rb:25:in `block in question_relation' TRANSACTION (1.8ms) COMMIT ↳ app/models/user.rb:25:in `block in question_relation' TRANSACTION (0.1ms) BEGIN ↳ app/models/user.rb:25:in `block in question_relation' User Load (0.1ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 69], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' Question Load (0.1ms) SELECT \"questions\".* FROM \"questions\" WHERE \"questions\".\"id\" = $1 LIMIT $2 [[\"id\", 1], [\"LIMIT\", 1]] ↳ app/models/user.rb:25:in `block in question_relation' UserQuestion Create (0.3ms) INSERT INTO \"user_questions\" (\"user_id\", \"question_id\", \"result\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 69], [\"question_id\", 1], [\"result\", nil], [\"created_at\", \"2022-09-01 13:16:31.962690\"], [\"updated_at\", \"2022-09-01 13:16:31.962690\"]] ↳ app/models/user.rb:25:in `block in question_relation' TRANSACTION (0.5ms) COMMIT ↳ app/models/user.rb:25:in `block in question_relation'もう一つのデメリットとしては、最初から全部の質問と紐づいて、後でユーザーが質問を答えたら、また質問レコードを取得して、データを更新する操作が必要。それで質問レコードを取得するクエリ自体も重複発行になる。修正後のコードは、まず一括紐付けるのでなく、ユーザーが質問回答してから、該当の質問と紐付けるようにする。ユーザーが選択した回答も紐付けと一緒に記録する。修正後コード def save_result(question, result) user_questions.create(question_id: question.id, result: result) end 修正後SQLクエリ発行状況 Question Load (0.2ms) SELECT \"questions\".* FROM \"questions\" WHERE \"questions\".\"id\" = $1 LIMIT $2 [[\"id\", 1], [\"LIMIT\", 1]] ↳ app/models/user.rb:19:in `save_result' UserQuestion Create (0.5ms) INSERT INTO \"user_questions\" (\"user_id\", \"question_id\", \"result\", \"created_at\", \"updated_at\") VALUES ($1, $2, $3, $4, $5) RETURNING \"id\" [[\"user_id\", 60], [\"question_id\", 1], [\"result\", 0], [\"created_at\", \"2022-09-01 11:57:34.573782\"], [\"updated_at\", \"2022-09-01 11:57:34.573782\"]] ↳ app/models/user.rb:19:in `save_result' TRANSACTION (5.8ms) COMMIT ↳ app/models/user.rb:19:in `save_result'政党ポイント計算メソッド修正政党ポイント計算のロジックとしては、 ユーザー選択が超賛成の議題に対して、政党意見が–賛成の場合、該当政党との相性度+2点反対の場合、相性度-1点 ユーザー選択が賛成の議題に対して、政党意見が–賛成の場合、政党との相性度+1点反対の場合、相性度-1点 ユーザー選択が反対の議題に対して、政党意見が–賛成の場合、該当政党との相性度-1点反対の場合、相性度+1点 ユーザー選択が無関心の議題に対して、政党との相性度が加減しないつまり、政党とユーザー意見が一致したら、加点になる、正反対だったら減点になること。最初から政党を賛成派と反対派を分けて、データ更新したいつもりだったけど、必要な参照データがuser_questionsテーブル、user_partiesテーブルとparty_quesionsテーブルの三つのテーブルに分散しているので、うまくデータを一括操作する方法が思い出さなかった。とりあえず、政党意見を一つ一つ取り出して、ユーザー意見と比較する方法にした。作成したコードもややこしい感じで、チームメンバーに理解してもらうのが時間かかったそう。 修正前のコード1. まずcontrollerのアクション内で、ユーザーと政党の中間テーブルuser_partiesからをユーザーと紐づいた政党レコードを一つ一つ取り出して、ポイント計算を行う current_user.user_parties.each do |user_party| user_party.calculate_point(user_question) end2. ポイント計算のメソッドの中身として、まず政党と質問の中間テーブルparty_questionsから政党意見を取得し、 そしてユーザー意見と比較して、一致したら、加点する;不一致だったら、減点する。 def calculate_point(user_question) # 政党意見を参照するため、party_questionsテーブルから政党を取得してopinionを参照する party_questions = PartyQuestion.where(question_id: user_question.question_id) party_question = party_questions.find_by(party_id: party_id) # ユーザーの選択意見 user_result = user_question.result #　ユーザーと政党の意見が一致する場合、政党pointを加点する if user_question.agree_with_party?(party_question) add_point(user_result) # ユーザーと政党の意見が正反対の場合、政党pointを減点する # 政党が中立やユーザー意見が無回答の場合は、処理なし elsif user_question.disagree_with_party?(party_question) reduce_point(user_result) end end3. さらにユーザーと政党意見の一致か不一致かを判断するメソッドを追加する ここは中間テーブル名を挟んで、見た目もややこしい感じになっている。 # ユーザ意見が政党と一致する場合 # つまり両方とも賛成、あるいはともに反対する場合 def agree_with_party?(party_question) both_agree?(party_question) || both_disagree?(party_question) end # ユーザ意見が政党と不一致する場合 # つまり一方が賛成で、もう一方は反対 def disagree_with_party?(party_question) user_positive_but_party_disagree?(party_question) || user_negative_but_party_agree?(party_question) end # 議題に対して、ユーザも政党も賛成する場合 def both_agree?(party_question) result_positive? &amp;&amp; party_question.agree? end # 議題に対して、ユーザも政党も反対する場合 def both_disagree?(party_question) result_negative? &amp;&amp; party_question.disagree? end # 議題に対して、ユーザが賛成する場合 # つまり選択意見が超賛成か賛成の場合 def result_positive? self.great? || self.good? end # ユーザ意見が反対の場合 def result_negative? self.bad? end # 議題に対して、ユーザが賛成で、政党が反対する場合 def user_positive_but_party_disagree?(party_question) result_positive? &amp;&amp; party_question.disagree? end # 議題に対して、ユーザが反対で、政党が賛成する場合 def user_negative_but_party_agree?(party_question) result_negative? &amp;&amp; party_question.agree? end4. 最後に加点と減点を実行するメソッド # ユーザー意見が超賛成の場合、政党point+2 # ユーザー意見が賛成の場合、政党point+1 def add_point(user_result) if user_result == \"great\" self.point += 2 save elsif user_result == \"good\" self.point += 1 save end end # ユーザーと政党が正反対の場合合、政党point-1 def reduce_point(user_result) self.point -= 1 save end修正前のSQLクエリ発行も政党の数分で政党意見取得と政党ポイント更新の2重発行になっている。 修正前SQLクエリ発行状況# 修正前User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 70], [\"LIMIT\", 1]] ↳ app/controllers/application_controller.rb:5:in `current_user' UserParty Load (0.2ms) SELECT \"user_parties\".* FROM \"user_parties\" WHERE \"user_parties\".\"user_id\" = $1 [[\"user_id\", 70]] ↳ app/controllers/questions_controller.rb:15:in `answer' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 1], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 2], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 2], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.4ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 4], [\"updated_at\", \"2022-09-01 13:23:01.801733\"], [\"id\", 513]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 3], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.2ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.3ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 4], [\"updated_at\", \"2022-09-01 13:23:01.809307\"], [\"id\", 514]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 4], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 4], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.3ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 1], [\"updated_at\", \"2022-09-01 13:23:01.815549\"], [\"id\", 515]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 5], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 5], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.4ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 1], [\"updated_at\", \"2022-09-01 13:23:01.822521\"], [\"id\", 516]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 6], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 6], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.2ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 4], [\"updated_at\", \"2022-09-01 13:23:01.829242\"], [\"id\", 517]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.5ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 7], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 7], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.4ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 1], [\"updated_at\", \"2022-09-01 13:23:01.835753\"], [\"id\", 518]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.2ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 8], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 8], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.2ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 1], [\"updated_at\", \"2022-09-01 13:23:01.842407\"], [\"id\", 519]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.5ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point' PartyQuestion Load (0.1ms) SELECT \"party_questions\".* FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"party_id\" = $2 LIMIT $3 [[\"question_id\", 2], [\"party_id\", 9], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:11:in `calculate_point' TRANSACTION (0.1ms) BEGIN ↳ app/models/user_party.rb:30:in `add_point' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 9], [\"LIMIT\", 1]] ↳ app/models/user_party.rb:30:in `add_point' UserParty Update (0.3ms) UPDATE \"user_parties\" SET \"point\" = $1, \"updated_at\" = $2 WHERE \"user_parties\".\"id\" = $3 [[\"point\", 2], [\"updated_at\", \"2022-09-01 13:23:01.848200\"], [\"id\", 520]] ↳ app/models/user_party.rb:30:in `add_point' TRANSACTION (0.4ms) COMMIT ↳ app/models/user_party.rb:30:in `add_point'修正後のロジックはなるべく設計の時の考え方をそのまま反映するようにした。まず個々の政党でなく、ユーザーと紐づいた政党レコードを一括更新できるようにする。current_user.user_parties.calculate_point(@question, result)そして賛成意見を持つ政党リストと反対意見を持つ政党リストを取得する。最後にupdate_allメソッドを使って、ふたつグループの政党ポイントを一括更新する。 def self.calculate_point(question, user_result) # 該当質問に賛成意見を持つ政党リストを取得 agree_party_ids = question.party_questions.where(opinion: :agree).pluck(:party_id) agree_user_parties = self.where('party_id IN (?)', agree_party_ids) # 該当質問に反対意見を持つ政党リストを取得 disagree_party_ids = question.party_questions.where(opinion: :disagree).pluck(:party_id) disagree_user_parties = self.where('party_id IN (?)', disagree_party_ids) case user_result when \"great\" # ユーザーが超賛成の場合 agree_user_parties.update_all(\"point = point + 2\") disagree_user_parties.update_all(\"point = point - 1\") when \"good\" # ユーザーが賛成の場合 agree_user_parties.update_all(\"point = point + 1\") disagree_user_parties.update_all(\"point = point - 1\") when \"bad\" # ユーザーが反対の場合 agree_user_parties.update_all(\"point = point - 1\") disagree_user_parties.update_all(\"point = point + 1\") end end 修正後SQLクエリ発行状況# 修正後 User Load (0.3ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 60], [\"LIMIT\", 1]] ↳ app/controllers/application_controller.rb:5:in `current_user' PartyQuestion Pluck (0.3ms) SELECT \"party_questions\".\"party_id\" FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"opinion\" = $2 [[\"question_id\", 1], [\"opinion\", 0]] ↳ app/models/user_party.rb:9:in `calculate_point' PartyQuestion Pluck (0.2ms) SELECT \"party_questions\".\"party_id\" FROM \"party_questions\" WHERE \"party_questions\".\"question_id\" = $1 AND \"party_questions\".\"opinion\" = $2 [[\"question_id\", 1], [\"opinion\", 1]] ↳ app/models/user_party.rb:12:in `calculate_point' UserParty Update All (0.6ms) UPDATE \"user_parties\" SET point = point + 2 WHERE \"user_parties\".\"user_id\" = $1 AND (party_id IN (1,2,3,6)) [[\"user_id\", 60]] ↳ app/models/user_party.rb:17:in `calculate_point' UserParty Update All (0.7ms) UPDATE \"user_parties\" SET point = point - 1 WHERE \"user_parties\".\"user_id\" = $1 AND (party_id IN (4,5,7,8)) [[\"user_id\", 60]] ↳ app/models/user_party.rb:18:in `calculate_point'結果一覧メソッドの修正結果ページでは政党ポイントランキングを表示する。ここでchartjsを使うので、政党名と政党ポイントを分けて取得する必要最初のやり方としては、まず政党とポイントをそれぞれ空の配列を作成し、user_partiesテーブルから一つ一つレコードを取得して、配列にデータをpushする。これも政党の数分でSQLが発行される。修正前コードdef result user_parties = UserParty.where(user_id: current_user.id) @results = user_parties.ranking parties = [] points = [] @results.each do |result| point = result.point party_name = result.party.name parties.push(party_name) points.push(point) end 修正前SQLクエリ発行状況# 修正前Processing by StaticPagesController#result as TURBO_STREAM User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 60], [\"LIMIT\", 1]] ↳ app/controllers/application_controller.rb:5:in `current_user' UserParty Load (0.3ms) SELECT \"user_parties\".* FROM \"user_parties\" WHERE \"user_parties\".\"user_id\" = $1 ORDER BY \"user_parties\".\"point\" DESC [[\"user_id\", 60]] ↳ app/controllers/static_pages_controller.rb:11:in `result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 6], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 9], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 3], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.2ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 8], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 4], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 7], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 2], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 1], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Party Load (0.1ms) SELECT \"parties\".* FROM \"parties\" WHERE \"parties\".\"id\" = $1 LIMIT $2 [[\"id\", 5], [\"LIMIT\", 1]] ↳ app/controllers/static_pages_controller.rb:13:in `block in result' Rendering layout layouts/application.html.erb修正後は、joinsとpluckメソッド使って、政党ポイントデータを一括取得する def result user_parties = current_user.user_parties.ranking parties = user_parties.joins(:party).pluck(:name) points = user_parties.pluck(:point) end 修正後SQLクエリ発行状況# 修正後User Load (0.2ms) SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = $1 LIMIT $2 [[\"id\", 66], [\"LIMIT\", 1]] ↳ app/controllers/application_controller.rb:5:in `current_user' UserParty Pluck (0.4ms) SELECT \"name\" FROM \"user_parties\" INNER JOIN \"parties\" ON \"parties\".\"id\" = \"user_parties\".\"party_id\" WHERE \"user_parties\".\"user_id\" = $1 ORDER BY \"user_parties\".\"point\" DESC [[\"user_id\", 66]] ↳ app/controllers/static_pages_controller.rb:9:in `result' UserParty Pluck (0.2ms) SELECT \"user_parties\".\"point\" FROM \"user_parties\" WHERE \"user_parties\".\"user_id\" = $1 ORDER BY \"user_parties\".\"point\" DESC [[\"user_id\", 66]] ↳ app/controllers/static_pages_controller.rb:10:in `result'以上でSQLクエリが大量発行したコード部分をリファクタリングした。ただ政党ポイント計算のところはまだ改善の余地があるかなと思った。後日またやってみたい。参照https://stackoverflow.com/questions/4967191/mass-increment-field-by-1https://phrase.com/blog/posts/activerecord-speed-up-your-sql-queries/https://stackoverflow.com/questions/2509320/saving-multiple-objects-in-a-single-call-in-rails" }, { "title": "ActiveModelでは`text`型は指定不可のことについて", "url": "/22/08/rails-activemodel-datatype-text/", "categories": "Coding", "tags": "Ruby on Rails, SQL, MySQL, PostgreSQL", "date": "2022-08-14 00:00:00 +0900", "snippet": "今回のFormObjectでうっかりbodyのタイプをtextに指定してしまい、Unknown type :textのエラーが出た。調べたら、ActiveModelではtextタイプをサポートしてないことがわかった。サポートしているタイプはドキュメントでの明確な説明は見つからなかったが、ソースコードでのファイル名を見れば何とか推測できるRails APIでのファイル名リストを見ると、text...", "content": "今回のFormObjectでうっかりbodyのタイプをtextに指定してしまい、Unknown type :textのエラーが出た。調べたら、ActiveModelではtextタイプをサポートしてないことがわかった。サポートしているタイプはドキュメントでの明確な説明は見つからなかったが、ソースコードでのファイル名を見れば何とか推測できるRails APIでのファイル名リストを見ると、textが入ってないことがわかった。ActiveModel::Type一方、ActiveRecord::Typeではtextファイルがあって、中身を見ると、typeを:textに指定することができることがわかる。調べているところ、そもそもstringとtextは本質上で違いがないことがわかった。ActiveRecordでのtextはActiveModelのStringから継承している。(class Text &lt; ActiveModel::Type::StringActiveRecordでtext型を指定しても、取扱方はstringとはほぼ一緒。(違いはformでtext_areaタグを生成するぐらい？)そのため、ActiveModelでtext型を使いたい場合、単にstringにすれば良い。MySQLやPostgresSQLなどのDBでも、text型とvarchar型は本質上の違いがないらしい。例えば、PostgresSQLでは、varchar(n), char(n)とtextが格納できる最大文字長(1GB)は同じで、違いはtextは文字数上限指定がない、残りの二つは上限指定ができること。MySQLでは、似たような状況で、VARCHARとTEXTどちらも上限は65,535文字で、ただindex設定したい時や上限指定したい時は、VARCHARが良い。それより、元々SQL標準仕様では文字列のデータ型はCHARとVARCHARのみで、text型がない。参照Mimic SQL table with ActiveModel AttributesPostgreSQL: Difference between text and varchar (character varying)Difference between VARCHAR and TEXT in MySQLPostgreSQL Character TypesMySQL 11.3 String Data Types" }, { "title": "単一テーブル継承(STI)について", "url": "/22/08/rails-sti-single-table-inheritance/", "categories": "Coding", "tags": "Ruby on Rails, Database", "date": "2022-08-12 00:00:00 +0900", "snippet": "応用篇でのtaxonomiesテーブルは何なんだって気になってて、調べてみたら、単一テーブル継承(STI)で使ってるテーブルのことがわかった。同じ親クラスから継承している複数の子モデルの情報は各自のテーブルではなく、全てを親モデルのテーブルに記入する。各子モデルの情報はtypeコラムで標識する。今回はauthor, category, tagの三つのモデルの情報をtaxonomiesテーブル...", "content": "応用篇でのtaxonomiesテーブルは何なんだって気になってて、調べてみたら、単一テーブル継承(STI)で使ってるテーブルのことがわかった。同じ親クラスから継承している複数の子モデルの情報は各自のテーブルではなく、全てを親モデルのテーブルに記入する。各子モデルの情報はtypeコラムで標識する。今回はauthor, category, tagの三つのモデルの情報をtaxonomiesテーブルに記入しているどのモデルの情報かを標識するため、モデル名をtypeコラムに記入する。それで、三つのテーブルそれぞれ作成するのが不要になる。本当はDBには一つの集約テーブルしか存在しないけど、レコードを取得するとき、それぞれのテーブルが存在するかのように扱える例えば、authorのレコードを全部取得するなら、普通にAuthor.allでいける。実際に発行するSQL文はSELECT \"taxonomies\".* FROM \"taxonomies\" WHERE \"taxonomies\".\"type\" IN ('Author')ただ現場ではSTIはあまり活用されていないようで、qiitaで向き不向きの議論があった 単純にtypeフィールドが文字列で入るので空間効率が良くない。とくにレコード件数が数億件を超えるような時系列テーブルになると、この反復は無視できない STIとして実装したサブクラスには独自メソッドが1個か2個しかないようなケースも多く、ほとんどが共通の処理で、このような場合にはサブクラスの定義ファイルが分割されてしまうのはかえって見通しを悪くしてしまい 多段継承がない場合、enumで処理の異なる部分だけを分岐してやったほうが、全体としてコピペも減り、フローも追いやすくなる サードパーティのgemがSTIでの利用を考慮していないため、実装上うまくいかなくて、そのgemの利用が無理になったケースが多いそれより、今回の場合は、記事のカテゴリやタグと作者は同じクラスから継承していていることは、個人的にちょっと違和感を感じた。author, category, tagそれぞれnameやslug、descriptionとの共通属性があったため、STIを使ったのか、と思うけど。現実世界のものから考えると、カテゴリとタグは似たような性質があって、サブクラスとして一緒に扱うのが問題ないかもしれないけど、作者はちょっと違うかなと思った..参照シングルテーブル継承 （STI）クラスの継承（単一テーブル継承）みんなRailsのSTIを誤解してないか!?" }, { "title": "Capybaraで新しいwindowを指定するため、window contextを切り替える方法", "url": "/22/08/capybara-change-context-of-window/", "categories": "Coding", "tags": "RSpec, Ruby on Rails, Test, Capybara", "date": "2022-08-05 00:00:00 +0900", "snippet": "Capybara で system テストを行った時、can't find element'のエラーが出た。 byebugとpage.body`で確認したら、リンクをクリックした前のページに止まっていることがわかった。調べてみたら、その原因はページ内のリンクをクリックして、新規 window/tab で開く場合は、window contextは自動切り替えがなく、前のページに止まること。解決...", "content": "Capybara で system テストを行った時、can't find element'のエラーが出た。 byebugとpage.body`で確認したら、リンクをクリックした前のページに止まっていることがわかった。調べてみたら、その原因はページ内のリンクをクリックして、新規 window/tab で開く場合は、window contextは自動切り替えがなく、前のページに止まること。解決方法はwindow contextを指定すること。主に二つ種類があり、複数の window が開いたまま、使いたい window context を指定するか、一つの window context を維持するようにする。まずは複数 window context のままで使いたい context を指定する方法一番簡単なのは、switch_to_windowメソッドを使うclick__on \"the link that opens the new tab\"switch_to_window(windows.last)あるいはswitch_to_window( window_opened_by { click_on \"the link that opens the new tab\" },)二つ目の方法は、｀ within_window ｀メソッドを使うwithin_window(windows.last) do # code hereendあるいはnew_window = window_opened_by { click_link \"the link that opens the new tab\" }within_window(new_window) { click_link \"the link inside the new tab\" }new_window.close # if you want to close the tab that was openedもし複数の window context がいらない、今の window context のみを残すなら、visit find_link(\"the link that opens the new tab\")[\"href\"]これで今の window context が維持される。参照:With Capybara, how do I switch to the new window for links with “_blank” targets?Changing the focus of the window on CapybaraClicked link and still on the same page (capybara)" }, { "title": "Missing Semester - The Shell", "url": "/22/07/mit-missing-semester-shell/", "categories": "Coding", "tags": "Shell, Linux, MIT, Missing Semester", "date": "2022-07-17 00:00:00 +0900", "snippet": "MITのCS基礎コース「The Missing Semester of Your CS Education」についてのメモ。Course located at: https://missing.csail.mit.edu/What is the shell A textual interface to the system A programming environment (like ...", "content": "MITのCS基礎コース「The Missing Semester of Your CS Education」についてのメモ。Course located at: https://missing.csail.mit.edu/What is the shell A textual interface to the system A programming environment (like ruby, python) which can run programs, commands, shell scripts. Also has functions, conditionals, path variables, loops.Using the shell Environment variable(環境変数) $ date2022年 7月29日 金曜日 15時20分22秒 JST$ echo HelloHelloWhen input a command, the shell will match one of its programming keywords.ex. Input date, the shell will execute the date program to print the date on the terminal.If the shell doesn’t match any keywords, it consults an environment variable, called $PATH, that lists which directories the shell should search for programs when it is given a command.$ echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin$ which echo/bin/echo$ /bin/echo $PATH/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binUse man to check the manual of commandcomman like ls --help doesn’t work on MacOS, instead use man ls . (Press q to exit.)Connecting programsThe input stream and output streamIn the shell, programs have two primary “streams” associated with them: their input stream and their output stream. When the program tries to read input, it reads from the input stream, and when it prints something, it prints to its output stream.Normally, a program’s input and output are both your terminal. That is, your keyboard as input and your screen as output.Using cat with &lt; , &gt; and &gt;&gt;cat: a program that concatenates(連結) files.When given file names as arguments, it prints the contents of each of the files in sequence to its output stream.But when cat is not given any arguments, it prints contents from its input stream to its output stream.$ echo hello &gt; hello.txt # \"hello\" as input stream, \"hello.txt\" as output stream$ cat hello.txthello$ cat &lt; hello.txt # hello.txt as input streamhello$ cat &lt; hello.txt &gt; hello2.txt # prints contents from hello.txt to hello2.txt(output stream)$ cat hello2.txthellouse &gt;&gt; to append to a file.$ cat &lt; hello.txt &gt;&gt; hello2.txt$ cat hello2.txt #will get two lines of \"hello\"hellohelloUsing | operator to chain programsLike using the output of one program as the input of another program.$ ls -l / | tail -n1 # listing files under / and display the last linelrwxr-xr-x@ 1 root wheel 11 1 1 2020 var -&gt; private/varls -l: use a long listing format/: use / the home directory as argument of ls -ltail -n [number]: display the last part of a file, with nlines.$ curl --head --silent google.com | grep --ignore-case content-length | cut -d' ' -f 2219curl: transfer data to or from a server--head --silent: Fetch the headers only, in silent mode (without showing progress meter or error messages.)grep: a utiltiy that searches any given input files, selecting lines that match one or more patterns.Used like ` grep [search options] [file] grep –ignore-case content-length`: search the line matches “content-length” ignoring casecut: cut out selected portions of each line of a file-d (--delimiter) : Specify a delimiter(区切り文字) that will be used instead of the default “TAB” delimiter.-f (--fields=LIST) Select by specifying a field, a set of fields, or a range of fields. The most commonly used option.ex. for file test.txt245:789 4567 M:4540 Admin 01:10:1980535:763 4987 M:3476 Sales 11:04:1978to display the 1st and 3rd fields using “:” as a delimiter:$cut test.txt -d ':' -f 1,3# output will be245:4540\tAdmin\t01535:3476\tSales\t11Permission bits of the fileThere are 3 sets of permissions. One set for the owner of the file, another set for the members of the file’s group, and a final set for everyone else.$ ls -ldrwxrwxr-x 29 root admin 928 7 22 17:18 Applications-rw-r--r-- 1 mia staff 61 7 29 11:07 semesterfirst character: d: means a directory-: means a filenext 9 character indicates 3 sets:first 3 characters: permissions for the ownermidlle 3 characters: permissions for the group memberlast 3 characters: permissions for everyone elsePermission bits (characters indicate permissions):r: read, it ban be opened, and its content be viewedw: write, it can be edited, modified, and deletedx: execute, can be executed if it is a script or a program.Using Shebang #! and chmod#!interpreter [arguments]the exclamation mark (!) is used with the number sign/hash (#) symbol to specify the interpreter path. This usage is called “shebang” , or hashbang(#!`)Often used for writing shell scripts.When we try to run an executable file, the execve program is called to replace the current process (bash/zsh shell if we are using terminal) with a new one and decide how exactly that should be done.If we try to run a text file, execve expects the first two characters of the file to be “#!”  followed by a path to the interpreter that will be used to interpret the rest of the script.ex.$ echo '#!/bin/sh' &gt;&gt; greetings$ echo 'echo \"Hello, ${USER}\"' &gt;&gt; greetings$ cat greetings#!/bin/shecho \"Hello, ${USER}\"$ sh greetingsHello, miash: A shell command language interpreter that executes commands read from a command line string, the standard input, or a specified file.Using chmod to modify file permissionsTo use chmod to set permissions, we need to tell it: Who: Who we are setting permissions for. u, g, o, a( for ‘ user / group/ others / or all above without specifying) What: What change are we making? Are we adding or removing the permission? -: Remove permissions + : Add permissions = : Set a permission and remove others Which: Which of the permissions are we setting?r, w, x$ ls -l-rw-r--r-- 1 mia staff 32 7 29 17:38 greetings$ chmod +x greetings # add execute permission to all$ ls -l-rwxr-xr-x 1 mia staff 32 7 29 17:38 greetingsThen, greetings is an executable file$ ./greetingsHello, miaExercisesCreate a new directory called missing under /tmp.mkdir /tmp/missingUse touch to create a new file called semester in missing.touch /tmp/missing/semesterWrite the following into that file, one line at a time:#!/bin/shcurl --head --silent https://missing.csail.mit.eduecho '#!/bin/sh' &gt;&gt; semesterecho 'curl --head --silent https://missing.csail.mit.edu' &gt;&gt; semesterTry to execute the file, i.e. type the path to the script (./semester) into your shell and press enter. Understand why it doesn’t work by consulting the output of ls (hint: look at the permission bits of the file).No execution bitRun the command by explicitly starting the sh interpreter, and giving it the file semester as the first argument, i.e. sh semester. Why does this work, while ./semester didn’t? ./semester asks the kernel to run semester as a program, and the kernal (program loader) will check permissions first, and then use /bin/zsh (or sh or bash etc) to actually execute the script.sh semester asks the kernel (program loader) to run /bin/sh, not the program so the execute permissions of the file do not matter.Use chmod to make it possible to run the command ./semester rather than having to type sh semester. How does your shell know that the file is supposed to be interpreted using sh?$ chmod +x semester$ ./semesterHTTP/2 200 server: GitHub.comcontent-type: text/html; charset=utf-8x-origin-cache: HITlast-modified: Sat, 14 May 2022 10:50:11 GMTaccess-control-allow-origin: *etag: \"627f8963-1f37\"expires: Sat, 23 Jul 2022 03:08:29 GMTcache-control: max-age=600x-proxy-cache: MISSx-github-request-id: ED62:476C:5D2A8:BC4B1:62DB63D5accept-ranges: bytesdate: Fri, 29 Jul 2022 09:02:02 GMTvia: 1.1 varnishage: 0x-served-by: cache-tyo11976-TYOx-cache: HITx-cache-hits: 1x-timer: S1659085322.824124,VS0,VE435vary: Accept-Encodingx-fastly-request-id: 94ac286b0de6f5f883905082fa06aef9c1ce2227content-length: 7991 The shebang is parsed as an interpreter directive by the program loader mechanism. The loader executes the specified interpreter program, passing to it as an argument the path that was initially used when attempting to run the script, so that the program may use the file as input data.Use | and &gt; to write the “last modified” date output by semester into a file called last-modified.txt in your home directory.# get the 5th line$ ./semester | head -n 5 | tail -n 1 or $ ./semester | sed -n 5plast-modified: Sat, 14 May 2022 10:50:11 GMTor use grep$ ./semester | grep last-modified | cut -d ':' -f 2-4 | &gt; ~/last-modified.txt$ cat ~/last-modified.txt Sat, 14 May 2022 10:50:11 GMT参照：Cut Command in LinuxUsing Shebang #! in Linux Scriptscurl command in Linux with ExamplesHow to Use the chmod Command on Linux./missing-semester - Course Overview + The Shell - Exercises" }, { "title": "Deviseやsorceryを使わないやり方で、パスワードリセット機能の流れを理解する", "url": "/22/07/rails-password-reset/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-15 00:00:00 +0900", "snippet": "SorceryのReset passwordモジュールを使って、パスワードリセット機能を実装するという課題だったが、sorceryの手順でなんとなくできたけど、メソッドの意味や流れがなかなかうまく理解できなかった。それで補充情報を検索してみたら、gemを使わないやり方のyoutube解説動画を見つけた。必要最小限のコードでパスワードリセット機能を作りながら、大体の流れを理解できてから、それを...", "content": "SorceryのReset passwordモジュールを使って、パスワードリセット機能を実装するという課題だったが、sorceryの手順でなんとなくできたけど、メソッドの意味や流れがなかなかうまく理解できなかった。それで補充情報を検索してみたら、gemを使わないやり方のyoutube解説動画を見つけた。必要最小限のコードでパスワードリセット機能を作りながら、大体の流れを理解できてから、それを参照にして、soceryの動きもなんとなくイメージできるようになった。 参照した動画: Rails for Beginners Part 20~221. まずサンプルアプリの土台を作る Rails 6.1のsigned_id機能を使うので、Rails 6.1以上のバージョンを使う必要 簡単なユーザー登録、ログインとログアウト機能を作る。 Userモデルのコラムはemailとpassword_digestだけでも良い has_secure_password使用 password_resets_controllerのnewアクション、そしてリセット申請用のnewページとパスワード更新用のeditページを作成 password_resets部分のroutes設定 password_mailerとresetというメソッドを作るここまで実現できた流れは、パスワードリセットリンクをクリックして、newページが表示され、フォームからemailを記入するまで。2. createアクション def create @user = User.find_by(email: params[:email]) # フォームで記入したemailでユーザーを特定する if @user.present? PasswordMailer.with(user: @user).reset.deliver_later # ユーザーが存在する場合、PasswordMailerでresetの案内メールを送信する end redirect_to root_path, notice: \"パスワードリセット手順を送信しました\" # ユーザーが見つからなかった場合でも、送信したと伝える endPasswordMailer.with(user: @user).reset.deliver_laterについてwith(user:@user)でMailerに引数を渡して、Mailerでparams[:user]を使えるようになる。後でこのuserのglobal_idを使ってtokenを作る。今すぐ送信するdeliver_nowより、deliver_laterを使うのは、メール送信するのは時間かかるので、とりあえずcontrollerのアクションを実行完了させて、メールが送信したとユーザーに知らせることを優先。controllerのアクションが実行完了してから、ActionJobでメール送信を行う。3. PasswordMailerの動きresetアクション def reset @token = params[:user].signed_id(purpose: \"password reset\", expires_in: 15.minutes) # リセットの目的と15分の有効期限を引数で設定し、userのsigned_idを生成して、リセット用のURLに渡すための引数@tokenに代入する mail(to: params[:user].email, subject: 'パスワードリセットのご案内' ) endsigned_idについてsigned_idはRails 6.1での新機能で、モデルのインスタンスのglobal_idを暗号化したハッシュ値（署名）。Rails consoleで確認してみると、こんな感じ&gt;user = User.last&gt;user.to_global_id.to_s=&gt; \"gid://sample-app/User/3\" # userインスタンスを定義するURI global_idについて) signed_idとfind_signedについて) メール本文で使うURLpassword_reset_edit_url(token: @token)でurlにtokenを渡す。後でパスワードリセットの時、このtokenをfind_signedメソッドに渡してuserを特定することができる。ちなみに、ここのURLヘルパは絶対パスを生成する_urlを使うべき。_pathだと、相対パスになるので、外からアクセスできないため。configでMailerのhostを設定するMailerは、HTTPリクエストとは無関係で、どのドメインを使ってメールを送信するのか、Mailer自体はわからないため、host情報を明示する必要。hostパラメータを指定しないままで、リセットを申請したら、Missing host to link to! Please provide the :host parameter, set default_url_options[:host]というエラーが出る。それで、hostを設定する。(課題ではconfigというgemを使って一元管理するのが推奨) config.action_mailer.default_url_options = { host: \"localhost:3000\" }ここまで実現できた流れは、パスワードリセット申請を提出して、対象のemailアドレスにリセット用のURLを告知する案内メールを送る。4. editアクションとupdateアクション(新しいパスワードの設定と更新)editアクションpassword_reset_edit_url(token: @token)で生成したリンクをクリックしたら、editアクションが動く def edit @user = User.find_signed!(params[:token], purpose: \"password reset\")　　# もし15分のtoken期限が過ぎた場合、token(つまりsigned_id)がnilになる rescue ActiveSupport::MessageVerifier::InvalidSignature # 発生した例外を処理する redirect_to login_path, alert: \"トークンの有効期限が切れました。再度申請してください。\" endまずは、User.find_signed!(params[:token], purpose: \"password reset\")でリセットを申請したユーザーを特定する。もし15分のtoken期限が過ぎた場合、ActiveSupport::MessageVerifier::InvalidSignatureエラーが起こる。その例外の処理として、ログインページにredirectして、再度申請することを提示する。また、editページのform_withにはurl: password_reset_edit_path(token: params[:token]) を渡す必要。updateアクション新しいパスワードを記入して、提出したら、updateアクションが動く。 def update @user = User.find_signed!(params[:token], purpose: \"password reset\") if @user.update(password_params) redirect_to login_path, notice: \"パスワードは更新しました\" else render :edit end end private def password_params params.require(:user).permit(:password, :password_confirmation) endこれで、パスワードリセットリンクをクリックして、tokenが検証通過されてから、パスワード更新することができる。このやり方はsorceryの難しいメソッドより、だいぶわかりやすくなったので、もしsorceryの挙動が理解しづらいと感じたら、まずこれを参照にして、sorceryのコードを改めて理解するのが良いかも。" }, { "title": "Rails controllerの動きについて", "url": "/22/07/rails-controller/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-11 00:00:00 +0900", "snippet": "routeの設定やcontrollerの記述だけで、viewのレンダリングやデータの渡しなどRailsが自動的に動いてくれるとはわかるけど、でもどうやってできたの？って素朴な疑問があったのでちょっと調べてみた。面白いと感じたので、メモしておく。 URLにアクセスした後、controllerの動き 仮に/boards/indexにアクセスしたら、Ra...", "content": "routeの設定やcontrollerの記述だけで、viewのレンダリングやデータの渡しなどRailsが自動的に動いてくれるとはわかるけど、でもどうやってできたの？って素朴な疑問があったのでちょっと調べてみた。面白いと感じたので、メモしておく。 URLにアクセスした後、controllerの動き 仮に/boards/indexにアクセスしたら、Rails は関連のcontrollerインスタンスを作成する。イメージ例：kontroller = BoardsController.new routingのマッピングによって、このkontrollerインスタンスはindexメソッドを実行する。 @boardsなどのインスタンス変数に関連データを保存する。 indexメソッドの最後の動きとしてデフォルトでindex.html.erbをレンダリングしようとする。 controllerメソッドの戻り値 Rubyではメソッドの最後にreturnを明記する必要がないが、indexメソッドは最後に評価する式は return render 'index'と思っても良い つまり戻り値はレンダリングしたviewページとなる もし他のviewページをメソッドの最後に明記したら、index以外のページをレンダリングすることになる。 conrollerからデータをviewに渡す仕組み 他に定義したRubyメソッドを使ってcontrollerのインスタンス変数名と値をコピーしてviewのインスタンスに持たせること 普通のローカル変数だと、indexメソッド外から参照できないので、ここでインスタンス変数を使うわけ っていうことは、viewファイルで使っている@boardsは、実はviewクラスのインスタンスがコピした同じ名前と同じ値を持つviewのインスタンス変数? Railsではインスタンス変数を使って、controllerからviewへのデータ共有を実現しているが、通常のOOPでのインスタンス変数の使い方とはズレているので、ちょっと議論があるけど..他のMVCモデルを使うフレームワークはデータの共有はどうやって実現しているだろうRailsの動きについて、いつも魔法的な感じだったけど、実は全てクラスやインスタンス、メソッドなどで実現していることは改めてわかった。参照:How are Rails instance variables passed to views?Howcome an Instance variable @variable defined in the controller’s action can be called from its views?Sending Data Between Rails Controllers and Views" }, { "title": "replaceWith()とhtml()の違い", "url": "/22/07/replace-with-html/", "categories": "Coding", "tags": "JavaScript, jQuery, Ruby on Rails", "date": "2022-07-10 00:00:00 +0900", "snippet": " replaceWith()はタグとタグの中身内容を含めて置き換える html()はタグの中身内容だけを置き換える例えば、置き換え前のコードは&lt;a id=\"js-bookmark-button-for-board-1\" class=\"float-right\" data-remote=\"true\" rel=\"nofollow\" data-method=\"post\" href=\"/bo...", "content": " replaceWith()はタグとタグの中身内容を含めて置き換える html()はタグの中身内容だけを置き換える例えば、置き換え前のコードは&lt;a id=\"js-bookmark-button-for-board-1\" class=\"float-right\" data-remote=\"true\" rel=\"nofollow\" data-method=\"post\" href=\"/bookmarks?board_id=1\"&gt; &lt;i class=\"far fa-star\"&gt;&lt;/i&gt;&lt;/a&gt;replaceWith()でaタグを含めて置き換えたらこうなる&lt;a id=\"js-bookmark-button-for-board-1\" class=\"float-right\" data-remote=\"true\" rel=\"nofollow\" data-method=\"delete\" href=\"/bookmarks/28\"&gt;　&lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;&lt;/a&gt;一方で、html()なら、aタグの中身だけが置き換えられる、つまり&lt;i class=\"far fa-star\"&gt;&lt;/i&gt;部分だけが置き換えられる。&lt;a id=\"js-bookmark-button-for-board-1\" class=\"float-right\" data-remote=\"true\" rel=\"nofollow\" data-method=\"post\" href=\"/bookmarks?board_id=1\"&gt; &lt;a id=\"js-bookmark-button-for-board-1\" class=\"float-right\" data-remote=\"true\" rel=\"nofollow\" data-method=\"delete\" href=\"/bookmarks/28\"&gt;　　 &lt;i class=\"fas fa-star\"&gt;&lt;/i&gt;　 &lt;/a&gt; &lt;/a&gt;二重のaタグ構造になってしまった。だから今回はreplaceWith()を使う。" }, { "title": "No newline at end of fileエラーについて", "url": "/22/07/no-newline-error/", "categories": "Coding", "tags": "Ruby, Ruby on Rails, UNIX", "date": "2022-07-10 00:00:00 +0900", "snippet": "毎回Lintチェックで怒られたエラー..なんで最後に新しい行が必要なの？と調べたら、理解が全然間違った。。ここのnewlineは新しい行の’new line’ではなく、newline記号のことだ。いわゆる行末記号(改行記号とも言われるらしい)No newline at end of fileは末尾に新しい行がないではなく、末尾に行末記号がないという理解の方がより正しい。newlineはlin...", "content": "毎回Lintチェックで怒られたエラー..なんで最後に新しい行が必要なの？と調べたら、理解が全然間違った。。ここのnewlineは新しい行の’new line’ではなく、newline記号のことだ。いわゆる行末記号(改行記号とも言われるらしい)No newline at end of fileは末尾に新しい行がないではなく、末尾に行末記号がないという理解の方がより正しい。newlineはline endingやend of line(EOL)とも言われるので、このエラーはEOL記号がないと理解しても良い。参照:Why should text files end with a newline?" }, { "title": "RailsでのN+1問題の原因と対策", "url": "/22/07/N-1-problem/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-07 00:00:00 +0900", "snippet": "N+1問題の原因Lazy loading の設計で、テーブル情報が必要になった時だけ、SQLクエリを発行して取得する。そのせいで、投稿一覧画面を表示するとき、個々の投稿の表示が処理されるたびに、ユーザー情報を取得するSQLクエリが発行されることになる。n個の投稿があるなら、ユーザー情報を取得するクエリがn回発行されるSELECT \"users\".* FROM \"users\" WHERE \"u...", "content": "N+1問題の原因Lazy loading の設計で、テーブル情報が必要になった時だけ、SQLクエリを発行して取得する。そのせいで、投稿一覧画面を表示するとき、個々の投稿の表示が処理されるたびに、ユーザー情報を取得するSQLクエリが発行されることになる。n個の投稿があるなら、ユーザー情報を取得するクエリがn回発行されるSELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" = ? 　x 　 n回ただ投稿コレクションを1回のクエリSELECT \"boards\".* FROM \"boards\" で一括取得したこれで 1 + N の問題が起こっている。対策法Lazy loadingをeager loadingにする 。つまりテーブル情報を事前取得しておくこと。Railsでは三つのメソッドを提供しているーー1. includesメソッド利用IN句で参照する情報を事前取得する -&gt; SELECT \"users\".* FROM \"users\" WHERE \"users\".\"id\" IN (....)ただwhere句で関係付けのテーブル情報を絞り込みたい場合は、referencesの指定が必要Board.all.includes(:user).where('user.name = ?', '太郎').references(:users)orBoard.all.includes(:user).where(users: {name:'太郎'})2. preloadメソッドincludesの基本挙動と同じで、関係付けのテーブル情報の絞り込みが不可3. eager_loadメソッドLEFT JOINを使って1つのクエリだけで関連するレコードをすべて取り出す。includes.where.referencesの挙動と同じRails 4以前は、includesがよしなにpreloadの方法か、eager_loadの方法か、振り分けてくれるけど、Rails 4以降は基本挙動はpreloadと同じになった。N+1問題の検出方法gem 'bullet' N+1問題の発生を監視するgem 'rack-mini-profiler' SQLクエリ、CPUの消費時間などを計測する。N+1問題の解消前後のパフォーマンス変化が直感できる参照:Rails: JOINすべきかどうか、それが問題だ — #includesの振舞いを理解するThe (Silver) Bullet for the N+1 Problemhttps://www.mehdi-khalili.com/orm-anti-patterns-part-3-lazy-loading" }, { "title": "INDEX、複合INDEX、UNIQUE制約とUNIQUE INDEXについて", "url": "/22/07/unique-constraint-and-unique-index/", "categories": "Coding", "tags": "Ruby, Ruby on Rails, Database", "date": "2022-07-06 00:00:00 +0900", "snippet": "INDEXとは特定のカラムからデータを取得する際に、テーブルの中の特定のカラムのデータを複製し検索が行いやすいようにしたもの。例えばユーザー名を検索する場合、データベースはデフォルトで表の1行目から最後まで探す、いわゆる全表スキャン（Full-table Scan）の方法。　もしユーザー名にindexをつけると、本の索引のように、アルファベット順などのアルゴリズムを使って途中から探すようにな...", "content": "INDEXとは特定のカラムからデータを取得する際に、テーブルの中の特定のカラムのデータを複製し検索が行いやすいようにしたもの。例えばユーザー名を検索する場合、データベースはデフォルトで表の1行目から最後まで探す、いわゆる全表スキャン（Full-table Scan）の方法。　もしユーザー名にindexをつけると、本の索引のように、アルファベット順などのアルゴリズムを使って途中から探すようになる。検索が早くなる。　ただデメリットとしては、書き込みの速度が倍かかる。 だから闇雲にインデックスを付けてはいけないという記事がある。Railsではreferences型を指定すると、外部キーとインデックスが自動的に作ってくれる。（Mysqlなどのデータベースでは外部キーとインデックス作成のセットが必須と要求されているが、そうでもないDBがあるらしい。ただ外部キーのインデックスを作成した方が良いとの説がある。理由はインデックスを設置しないと整合性チェックは子表全体のテーブルフルスキャンが実行される。 そのためにデッドロックが発生する可能性を抱えることになってしまうとのこと）複合インデックスとは複数のカラムを組み合わせたインデックス。今回はuserとboardの組み合わせの一意を保証するため、DB側で add_index :bookmarks, [:user_id, :board_id], unique: trueも追加することで、user_idとboard_idの複合インデックスを作成して、ユニーク制約をかけることにした。「[闇雲にインデックスを付けてはいけない」という記事を読んだので、複合インデックスより、単純なユニーク制約をかけるなど他の方法はないか、と思ったけど、実はユニーク制約とユニークインデックスについての理解が間違えた。。ユニーク制約とユニークインデックス　ユニーク制約はコラムのレコードに対して重複を禁止する制約。　ユニークインデックスは、レコードの重複を禁止するインデックス。一種のオブジェクト。　あるコラムにユニーク制約をかけると、このコラムのユニークインデックスが自動的に生成される。ユニーク制約が重複チェックを行う際に、ユニークインデックスを使ってチェックを行っている。つまり、ユニーク制約はユニークインデックスの目的とも言える。　だから、ユニーク制約をかけるには、ユニークインデックスの作成が必須ということ。` add_index :bookmarks, [:user_id, :board_id], unique: true`はもう忘れられない :rolling_on_the_floor_laughing:参照【SQL】UNIQUE制約についてのあれこれ。似ている名前”ユニークインデックス”との違いやカラムの組み合わせについて解説Difference between SQL Server Unique Indexes and Unique Constraintsデータベースにindexを張る方法" }, { "title": "redirect_backとredirect_back_or_toについて", "url": "/22/07/redirect-back-or-to/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-06 00:00:00 +0900", "snippet": "redirect_back fallback_location: root_pathは初めて見た使い方で、redirect_back_or_toとの違いを調べていた。Rails APIではredirect_backはredirect_back_or_toのエイリアスで、後者よりやや非推奨と書いてた。理由はfallback_locationの引数は redirect_backでキーワード引数の...", "content": "redirect_back fallback_location: root_pathは初めて見た使い方で、redirect_back_or_toとの違いを調べていた。Rails APIではredirect_backはredirect_back_or_toのエイリアスで、後者よりやや非推奨と書いてた。理由はfallback_locationの引数は redirect_backでキーワード引数の形式で、redirect_back_or_toでは一番目の位置引数になっているとのこと。 Soft deprecated alias for redirect_back_or_to where the fallback_location location is supplied as a keyword argument instead of the first positional argument.こう見ると、ここではredirect_back_or_to root_pathを使った方が良いではないかと思い、やって見たら、redirect_backと同じ挙動はしなかった。おかしいなと思っていたところ、redirect_back_or_toはsorceryにより提供された便利なメソッドだとの話を思い出した。だとしたら、Railsでのredirect_back_or_toは新しくリリースしたメソッド？Railsドキュメントでは5.0から7.0まで適用と書いたので、新しいメソッドではないみたいだけど…ちょっと迷っているところ、こんなissueを見つけた。 Should Sorcery rename redirect_back_or_to? #296Rails 7 released a new method called redirect_back_or_to added by DHH as a replacement for the now soft-deprecated redirect_back: rails/rails#40671.That may conflict with the method by the same name defined by Sorcery. Should it be renamed? I’m opening an issue instead of a PR because I guess it’s not a trivial decision to make.なるほど！redirect_back_or_toはRails 7でリリースしたメソッドで、元々Sorceryが提供しているメソッド名と被ったため、Sorceryのメソッド名の変更が必要になったと。(Railsドキュメントも完全に信用してはいけないね。。)だから今回課題のアプリでは、redirect_back_or_toはまだ使えない、従来のredirect_backを使うべきということで疑問が解消した。ちなみに、先日Sorceryの開発者がこの問題を着手し始めてるそうで、Sorceryで使うredirect_back_or_toメソッド名が変更されるかも。参照Should Sorcery rename redirect_back_or_to? #296Rails API" }, { "title": "link_toメソッドでクエリパラメータを付与する", "url": "/22/07/link_to_parameter/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-06 00:00:00 +0900", "snippet": "最初はbookmarks#createアクションの中に、params[:board_id]という書き方に疑問を感じた。なんでparamsにboard_idが入ったのか？ def create board = Board.find(params[:board_id])boards/_bookmark.html.erbの中で、link_to bookmarks_path(board_id...", "content": "最初はbookmarks#createアクションの中に、params[:board_id]という書き方に疑問を感じた。なんでparamsにboard_idが入ったのか？ def create board = Board.find(params[:board_id])boards/_bookmark.html.erbの中で、link_to bookmarks_path(board_id: board.id)があった。ブックマークをクリックした瞬間、(board_id: board.id)のクエリパラメータがurlに入ってきた。だからアクセスするURLはbookmarks/?board_id=xxになるそれで、createアクションでparams[:board_id]でboard_id取得して、ブックマーク対象の投稿を取得する他のクエリパラメータの付与方法link_to \"Comment wall\", profile_path(@profile, anchor: \"wall\") =&gt; &lt;a href=\"/profiles/1#wall\"&gt;Comment wall&lt;/a&gt;link_to \"Ruby on Rails search\", controller: \"searches\", query: \"ruby on rails\"=&gt; &lt;a href=\"/searches?query=ruby+on+rails\"&gt;Ruby on Rails search&lt;/a&gt;link_to \"Nonsense search\", searches_path(foo: \"bar\", baz: \"quux\") =&gt; &lt;a href=\"/searches?foo=bar&amp;baz=quux\"&gt;Nonsense search&lt;/a&gt;Rails APIより他参照【Rails】link_toに任意のパラメータを付与する方法" }, { "title": "ルーティングのcollectionとmemberについて", "url": "/22/07/routes-collection-member/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-02 00:00:00 +0900", "snippet": "collectionとmemberの使い分けについて、ID取得必要かどうかで判断するとの説明が多く見かけて、理解が曖昧だったけど、stackoverflowの回答を見て、ようやく納得した内容をメモする。結論違いはrouteにidが付くか付かないかと言うより、個別リソースに対してのアクションなのか、リソース全体に対してのアクションなのか、ということ。特定のリソースに対してのアクションの場合、m...", "content": "collectionとmemberの使い分けについて、ID取得必要かどうかで判断するとの説明が多く見かけて、理解が曖昧だったけど、stackoverflowの回答を見て、ようやく納得した内容をメモする。結論違いはrouteにidが付くか付かないかと言うより、個別リソースに対してのアクションなのか、リソース全体に対してのアクションなのか、ということ。特定のリソースに対してのアクションの場合、memberを使う、そのリソースのIDを取得するresources :photos do member do get 'preview' endend 生成URL例：　/photos/1/preview　　 特定の写真のプレビューのため、その写真のidを取得する必要 生成するルーティングヘルパー:preview_photo_path(photo)　　　 特定の写真リソースのため、単数形のphotoになる リソース全体に対してのアクションの場合、 collectionを使う、個別リソースのID取得は不要resources :photos do collection do get 'search' endend 生成URL例：　/photos/search　　　 写真全体に対しての検索行動のため、個別写真のidは取得不要 生成するルーティングヘルパー:search_photos_path　　 写真リソース全体のため、複数形のphotosになる 参照：difference between collection route and member route in ruby on rails?" }, { "title": "provide と content_for、Streaming(viewとlayoutの評価順)について", "url": "/22/07/provide-content-for-streaming/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-07-01 00:00:00 +0900", "snippet": "動的タイトルを出力するため、content_forを使うのがよく見かけるけど、Rails Tutorialの中に、provideメソッドを推奨しているそう。 Railsでの開発経験者であれば、この時点でcontent_forを検討すると思いますが、残念ながらAsset Pipelineと併用すると正常に動作しないことがあります。provideメソッドはcontent_forの代替です。Ra...", "content": "動的タイトルを出力するため、content_forを使うのがよく見かけるけど、Rails Tutorialの中に、provideメソッドを推奨しているそう。 Railsでの開発経験者であれば、この時点でcontent_forを検討すると思いますが、残念ながらAsset Pipelineと併用すると正常に動作しないことがあります。provideメソッドはcontent_forの代替です。Rails APIでの説明では、 provide(name, content = nil, &amp;block)The same as content_for but when used with streaming flushes straight back to the layout. In other words, if you want to concatenate several times to the same buffer when rendering a given template, you should use content_for, if not, use provide to tell the layout to stop looking for more contents.またStreamingについては、 By default, Rails renders views by first rendering the template and then the layout. The response is sent to the client after the whole template is rendered, all queries are made, and the layout is processed. Streaming inverts the rendering flow by rendering the layout first and streaming each part of the layout as they are processed. This allows the header of the HTML (which is usually in the layout) to be streamed back to client very quickly, allowing JavaScripts and stylesheets to be loaded earlier than usual.なるほど。Railsでは、デフォルトでveiwのtemplateを先に評価してから、layoutを評価する。そして全部の内容をユーザーにレンダリングする。だた、もしDBクエリが多いアクションを含めた場合、templateを評価するのは時間がかかるため、先にlayoutをレンダリングして、ページタイトルなどの基本内容をユーザーに表示させる方法はstreaming.content_forは、同じtemplateに複数併用が可能なので、Railsはtemplateを上から下まで評価して、複数のcontent_forを評価して、内容を連結する&lt;%= content_for :title, \"Hello\" %&gt; &lt;h1&gt;BOARD APP&lt;/h1&gt; &lt;%= content_for :title, \"World\" %&gt;content_forの内容は連結されるので、表示されるタイトルはHelloWorld | OARD APPになるつまり&lt;title&gt;HelloWorld | RUNTEQ BOARD APP&lt;/title&gt;一方で、provideの場合は、複数使うのが不可で、最初のprovideのみが評価される&lt;% provide :title, \"Hello\" %&gt; &lt;h1&gt;RUNTEQ BOARD APP&lt;/h1&gt; &lt;% provide :title, \"World\" %&gt;上記では、最初のprovideの内容のみが評価されるつまり&lt;title&gt;Hello | BOARD APP&lt;/title&gt;結論provide と content_for は基本的には同じだけど、もしDB操作が多くて、viewのtemplateが重たいなどの理由で、streamingを使いたい場合、provideを使うのが良い。そうすると、template最初のprovide部分のみを評価して、残りの部分を置いといて、layoutのところに戻る。残り疑問「content_forはAsset Pipelineと併用すると正常に動作しないことがある」と言うのはどういう場合？参照：Rails tutorialRails APIStreamingとはAssetPipelineとはrailsのアセットパイプラインについて解説するRuby on Rails: provide vs content_forRailsのviewとlayoutの評価順についてコードを読んで納得した" }, { "title": "パーシャルに渡す変数はなるべくローカル変数にした方が良い", "url": "/22/06/partial-variables/", "categories": "Coding", "tags": "Ruby, Ruby on Rails", "date": "2022-06-18 00:00:00 +0900", "snippet": "form_with model: postとfrom_with model: @postの2種類記法で戸惑っていたので、パーシャルに渡す変数について、調べていた。結論インスタンス変数か、ローカル変数か、form_withの挙動に特に影響がなさそうだが、パーシャルにはなるべくローカル変数を渡すのが良いことがわかった。理由インスタンス変数を使うと、コントローラとも結びついてしまい、パーシャルの再...", "content": "form_with model: postとfrom_with model: @postの2種類記法で戸惑っていたので、パーシャルに渡す変数について、調べていた。結論インスタンス変数か、ローカル変数か、form_withの挙動に特に影響がなさそうだが、パーシャルにはなるべくローカル変数を渡すのが良いことがわかった。理由インスタンス変数を使うと、コントローラとも結びついてしまい、パーシャルの再利用性が低くなる。例えば、controller側でインスタンス変数の名前や挙動を変更したとき、partial側も変更しなければならなくなる。特定のモデルのデータと関連づけられてしまうので、フレキシブルに使うことができない。参照:partialではインスタンス変数を参照しない方がいい【パーシャル】インスタンス変数の直接参照ではなく、localsで値を渡すform_with model:について" }, { "title": "Rubyの範囲演算子は降順のイテレートに使えないこと", "url": "/22/06/ruby-range-operator/", "categories": "Coding", "tags": "Ruby", "date": "2022-06-13 00:00:00 +0900", "snippet": "初めてアルゴリズムを勉強していたとき、バブルソートの方法を使って配列を降順にソートするプログラムを書くという課題で躓いていたところをメモする。プログラムは下記のように作成したけど、どうしてもソートできなかった。arr = [4, 5, 2, 1, 3]size = arr.sizemax = size - 1(0..(max-1)).each do |i| (max..(i+1)).eac...", "content": "初めてアルゴリズムを勉強していたとき、バブルソートの方法を使って配列を降順にソートするプログラムを書くという課題で躓いていたところをメモする。プログラムは下記のように作成したけど、どうしてもソートできなかった。arr = [4, 5, 2, 1, 3]size = arr.sizemax = size - 1(0..(max-1)).each do |i| (max..(i+1)).each do |j| if arr[j] &lt; arr[j-1] arr[j], arr[j-1] = arr[j-1], arr[j] end endendそして下記で試したところ、 (max..(i+1)).each do |j|が動かなかったことにようやく気づいた…(0..max).each do |i| p \"i = \" + i.to_s (max..(i+1)).each do |j| p \"j = \" + j.to_s if arr[j] &lt; arr[j-1] arr[j],　arr[j-1] = arr[j-1],arr[j] end p arr endend調べたら、Rubyでは(5..1).each doのように、範囲演算子が降順のイテレートに使いえないそうだ。下記に修正したら、うまくソートできた。 ((i+1)..max).reverse_each do |j|参照:Rubyの範囲演算子は降順のイテレートには使えない【Ruby】1..4の逆をしたいArray#reverse_each" } ]
